## 1.进程和线程

1. 进程是资源分配的基本单位，运行一个可执行程序可能运行一至多个进程，进程就是运行起来的可执行的程序；
2. 线程是独立调度、程序执行的基本单位，一个进程只有唯一的主线程；
3. 进程拥有CPU资源、内存资源、文件资源和句柄等，线程拥有程序计数器、寄存器、状态字和栈；
4. 进程的切换设计进程CPU环境的保存以及新调度的进程的CPU环境设置，开销较大、速度慢；线程只需要保存和设置少许的寄存器内容。

## 2.线程比进程具有哪些优势？

1. 线程的划分尺度比进程小，因此多线程程序的并发性高；
2. 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存与资源，极大地提高了程序的运行效率；
3. 线程切换的开销小、速度快，但不利于资源的管理和保护。

## 3.一个进程可以创建多少线程？

​		理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。

## 4.外中断和异常

- 外中断：是指由CPU执行指令以外的事件引起，如I/O完成终端等；
- 异常（内中断）：CPU执行指令的内部事件引起，如地址越界、算术溢出等。

## ？5.进程线程模型你知道多少？

## 6.进程调度算法

- 先来先服务算法
- 短作业优先
- 最短剩余时间优先
- 高响应比优先
- 时间片轮转
- 优先级调度
- 多级反馈队列

## 7.Linux下进程间通信方式？

- 管道
  - 有名管道FIFO
  - 匿名管道
- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专 门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。
- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 套接字
- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。
- 信号量

## 8.Linux下同步机制

1. 锁机制
   - 条件变量
   - 读写锁
   - 互斥锁
   - 自旋锁
2. 信号量
3. 信号
4. 屏障

## 9.什么是共享？

​		共享就是多个并发进程共用系统中的资源。

​		有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 10.动态分区分配算法有哪几种？

1. 首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区；

2. 最佳适应算法：优先使用更小的连续空闲区；

   缺点：每次都选最小的分区进行分配，会留下越来越多的很小且难以利用的内存块，这就是外部碎片；

3. 最坏适应算法：优先使用最大的连续空闲区；

4. 邻近适应算法：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区， 而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置 开始检索，就能解决上述问题。

## 11.内部碎片和外部碎片

- 内部碎片：分配给某些进程的内存区域上有些部分没用上，常见于固定分区分配。

  ​		内存总量相同，100M。

  - 分页式分配，固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了 5M，剩下的5M就是内部碎片； 
  - 分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。

- 外部碎片：内存中某些空闲区因为比较小，而难以利用，一般出现在内存动态分配方式中。

  - 分段式分配：内存总量相同，100M，比如内存分配依次5M，15M，50M，25M，程序运行一段时间 之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片

## ？12.如何消除碎片文件？

## 13.为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？

​		分段式分配是按需分配，而固定式分配是固定分配的方式

## 14.一个程序从开始运行到结束的完整过程

### （1）预编译（处理.c文件）

​		主要处理源代码文件中的以"#"开头的预编译指令。

1. 删除所有的#define，展开宏定义;
2. 处理所有的条件预编译指令;
3. 处理#include预编译指令，将文件内容替换到它的位置，这个过程是递归的；
4. 删除所有注释；
5. 保留所有的#pragma指令
6. 添加行号和文件表示，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能够显示行号。

### （2）编译（处理.i或.ii文件）

​		翻译成汇编文件，编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成和优化。

### （3）汇编（处理.s文件）

​		将汇编代码转变成机器可执行的指令（可重定位目标文件）。

​		Linux下生成.o文件，Windows下生成.obj文件

​		PS：**重定位就是将输入的多个可重定位目标文件合并为一个可执行目标文件。**

### （4）链接（处理.o文件）

​		将不同源文件生成的可重定位目标文件进行链接，从而形成一个可以执行的程序。

## 15.静态链接和动态链接？

## 16.进程同步的方法？

## 17.操作系统在对内存进行管理时需要做些什么？

- 操作系统需要负责对内存空间的分配与回收；
- 操作系统提供某种技术从逻辑上对内存空间扩充；
- 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换;
- 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。

## 18.虚拟技术你了解吗？

​		虚拟技术即把一个物理实体转换为多个逻辑实体。

​		主要有两种虚拟技术：时分复用技术和空分复用技术。

- 时分复用技术：多个进程能在同一个处理器上并发执行，是因为每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
- 空分复用技术：虚拟内存用到了空分复用技术。**它将物理内存抽象为地址空间，每个进程都有各自的地址空间。**地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 19.虚拟内存的目的与实现？

​		虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

​		为了更好的管理内存，操作系统将物理内存抽象成地址空间。**每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。**

​		这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中**。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。**

## 20.什么是内存？

​		内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理。

## 21.进程状态的切换？

![image-20210406205329710](E:\blog\Markdown\image-20210406205329710.png)

- 就绪态：进程获得了除处理机之外的一切资源，一旦得到处理机便可执行；
- 运行态：进程得到所有资源后正常执行。单处理机环境下，每个时刻只能由一个进程处于运行态;
- 阻塞态：进程正在等待某一事件而暂停运行，此时即使得到处理机资源也不能运行。

## 22.内存交换和覆盖有什么区别？

​		交换是不同进程之间进行，而覆盖则用于同一进程。

## 23.内存的覆盖是什么？有什么特点？

​		由于程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先 将那些即将要访问的段放入覆盖区，其他段放在外存中**，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。**

## 24.内存的交换是什么？有什么特点？

​		交换(对换)技术的设计思想：**内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存**(进程在内存与磁盘间动态调度)

## 25.抖动现象？（颠簸现象）

​		刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为 抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理 块不够)

## 26.交换空间与虚拟内存的关系？

- 交换空间：Linux中的交换空间在物理内存（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。

  交换空间的总大小应该相当于你的计算机内存的两倍和32 MB这两个值中较大的一个，但是它不能超过 2048 MB（2 GB）。

- 虚拟内存：虚拟内存使用的是硬盘的空间，Windows为了防止程序过大而使内存消耗殆尽，需要拿出一部分硬盘空间来充当内存使用。

## 27.内存交换中，被换出的进程保存在哪？

​		保存在磁盘中，也就是外存中。

​		具有对换功能的操作系统中，通常**把磁盘空间分为文件区和对换区两部分**。文件区主要用于存放文件，主要追求存储空间的利用率，因此对**文件区空间的管理采用离散分配方式**;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常**对换区采用连续分配方式**

## 28.在发生内存交换时，有哪些进程是被优先考虑的？

​		可优先换出阻塞进程；换出优先级低的进程，为了防止优先级低的进程在被调入内存后很快又被换出， 有的系统还会考虑进程在内存的驻留时间。

​		PCB会常驻内存，不会被换出外存

## 29.内存交换需要注意的关键点？

1. 交换需要备份存储，通常是快速磁盘，它必须足够大，**且提供对这些内存映像的直接访问**。
2. 为有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间， 转移时间与所交换的空间内存成正比。
3. 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。
4. 交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。

## 30.什么时候会进行内存的交换？

​		内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。

## 31.介绍一下几种经典的锁

### （1）读写锁

- 允许多个线程同时读共享数据
- 对写操作是互斥的
- 写者优先与读者

### （2）互斥锁（mutex）

​		一次只能一个线程拥有互斥锁。

​		**互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒**，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以 互斥锁在加锁操作时涉及上下文的切换。

### （3）条件变量

​		互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。**当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。**

### （4）自旋锁

​		如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。 

## 32.逻辑地址和物理地址？

​		相对地址又称逻辑地址，绝对地址又称物理地址。

​		编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。

## 33、僵尸进程和孤儿进程？

- 僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。

  **设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。**如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。

- 孤儿进程：如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程。 

  **一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程**。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

## 34、Windows和Linux环境下的内存分布情况

![image-20210407172003304](E:\blog\Markdown\image-20210407172003304.png)

​		通过这张图你可以看到，用户空间内存，**从低到高**分别是 7 种不同的内存段：

- 程序文件段（.text），包括二进制可执行代码； 
- 已初始化数据段（.data），包括静态常量； 
- 未初始化数据段（.bss），包括未初始化的静态变量； 
- 堆段（heap），包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关） 
- 栈段（stack），包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB 。当然系统也提供了参数，以便我们自定义大小；

## 35、一个由C/C++编译的程序占用的内存分为哪几个部分？

- 栈（stack）：地址向下增长，由编译器自动分配与释放，用以存放**函数的局部变量、函数参数、返回地址**等。其操作方式类似于数据结构中的队列，先进后出。
- 堆（heap）：地址向上增长，一般由程序员分配释放，就是malloc分配的内存块。其操作方式类似于链表（记录空闲地址空间的链表）。
- 全局区/静态区（.bss和.data段）：存放全局变量和静态变量，程序运行结束后由操作系统自动释放。在C语言中，**未初始化的放在.bss段中，初始化的放在.data中，在C++中不再区分**。
- 常量存储区（.data段）：存放常量，不允许修改，程序运行结束后自动释放
- 代码区（.text段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

## 36.一般情况下Linux/Windows平台下栈空间的大小

- Linux环境下有操作系统决定，一般是8KB；
- Windows环境下由编译器决定，VC++6.0一般是1M。

## 37.程序从堆中动态分配内存时，虚拟内存上怎么操作？

​		页表：是一个存放在物理内存中的数据结构，记录了虚拟页和物理页的映射关系。

​		在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，**操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表**（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。

## 38.从堆和栈上建立对象哪个快？

- 分配和释放：堆在分配和释放时都要调用malloc或free函数，比如分配时会到堆空间去寻找足够大小的空间（多次分配后会造成内存碎片），这些都会花费一定时间，而栈不需要这些。
- 访问时间：访问堆的一个具体单元，需要两次访存：第一次取得指针，第二次获取数据，而栈只需要一次。
- 访问位置：堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。

## 39.常见的内存分配方式？

1. 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量、静态变量。
2. 从栈上创建。执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时自动释放。
3. 从堆上分配，即动态内存分配。

## 40.常见内存分配错误

1. 内存分配未成功，却使用了它

   常用解决方法：使用内存前检查指针是否为NULL。

2. 内存分配成功，但未初始化就使用

3. 内存分配成功且初始化，但操作越界

4. 忘记释放内存，造成内存泄漏

5. 释放了内存却继续使用它。

   - 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。 
   - 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。 
   - 使用free或delete释放了内存后，没有将指针设置为NULL，导致产生“野指针”。