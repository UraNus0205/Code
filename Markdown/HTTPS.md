# 一、基本概念

​		**HTTP协议用于客户端和服务器端之间的通信。**

## 1.请求和响应报文

​		客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。

​		请求报文结构：

![image-20210323194521642](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323194521642.png)

​		响应报文结构：

![image-20210323195451875](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323195451875.png)

## 2.URI和URL

​		HTTP使用URL（统一资源定位符）来定位资源，它是URI（统一资源标识符）的子集，URL在URI的基础上增加了定位能力。URI除了URL，还包括URN（统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。

​		因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。**这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。只要能唯一标识资源的就是URI，在URI的基础上给出其资源的访问方式的就是URL。**

## 3.HTTP是不保存状态的协议

​		HTTP是一种不保存状态，即无状态协议。

​		HTTP/1.1索然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。

# 二、简单的HTTP协议

## 1.HTTP方法		

​		客户端发送的**请求报文**的第一行为请求行，包含了方法字段。

### （1）GET

> ​	获取资源

​		请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。若请求的资源是文本，则保持原样返回；若是像CGI（通用网关接口）那样的程序，则返回经过执行后的输出结果。

​		当前网络请求中，绝大部分使用的是GET方法。

![image-20210323201729239](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323201729239.png)

### （2）POST

> ​	传输实体主体

​		POST主要用于传输数据，而GET主要用来获取资源。

​		二者的比较见第九章。

![image-20210323201745882](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323201745882.png)

### （3）HEAD

> ​	获取报文首部

​		和GET方法类似，但是不返回报文实体主体部分。

​		主要用于确认URL的有效性以及资源更新的日期时间等。

![image-20210323201817243](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323201817243.png)

### （4）PUT

> ​	上传文件

​		由于HTTP/1.1的PUT方法不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

![image-20210323201803868](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323201803868.png)

### （5）PATCH

> 对资源进行部分修改

​		PUT也可以用于修改资源，但是只能**完全替代原始资源**，PATCH允许部分修改。

### （6）DELETE

> ​	删除文件

​		与PUT功能相反，用于删除文件。HTTP/1.1的DELETE方法同样不带验证机制。

​		PUT和DELETE方法配合Web应用程序的验证机制，或遵守REST（表征状态转移）标准时还是有可能会开放使用的。

![image-20210323202146395](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323202146395.png)

### （7）OPTIONS

> ​	查询支持的方法

​		查询指定的URL能够支持的方法。

![image-20210323202643507](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323202643507.png)

### （8）CONNECT

> ​	要求在与代理服务器通信时建立隧道

​		使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。

​		CONNECT方法的格式如下：

```
CONNECT 代理服务器名：端口号 HTTP版本
```

![image-20210323202855639](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323202855639.png)

### （9）TRACE

> ​	追踪路径

​		服务器会将通信路径返回给客户端。

​		发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输，最后收到请求的服务器端则返回状态码200 OK的响应。

​		**客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。**这是因为请求想要连接到源目标服务器可能会通过代理中转，**TRACE方法就是用来确认连接过程中发生的一系列操作。**

​		通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。

![image-20210323203308446](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323203308446.png)

## 2.持久连接节省通信量

​		HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接，即非持久连接。每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。

### （1）持久连接

​		为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（**即HTTP keep-alive**）。持久连接的特点是，只要任意一端没有明确提出断开连接，就保持TCP连接状态。

​		在HTTP/1.1中，所有连接默认都是持久连接。

### （2）管线化

​		持久连接使得多数请求以管线化（pipelining）方式发送称为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后可以同时并行发送多个请求，而不需要一个接一个地等待响应的。

## 3.使用Cookie的状态管理

​		HTTP是无状态协议，它无法根据之前的状态进行本次的请求处理。

​		Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。**Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。**当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

​		服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

![image-202103232051468770](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323205146877.png)

### （1）用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### （2）分类

- 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

### （3）JavaScript

​		浏览器通过 `document.cookie` 属性可创建新的 Cookie，**也可通过该属性访问非 HttpOnly 标记的 Cookie。**

### （4）HttpOnly

​		**标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用**。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `document.cookie` API 窃取用户的 Cookie 信息，**因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。**

### （5）Secure

​		**标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。**

### （6）Session

​		例如客户到KFC买东西，点了劲脆鸡腿堡、老北京鸡肉卷、可乐，服务员，将三个菜品一次放入打包盒，然后让你带走。如果使用Cookie解决需求，可以使用三个Cookie保存数据——但是有问题：**Cookie数量增多网络传输慢，解析慢**。最好的方式：

1. 需要一个容器来存放数据
2. 这个容器必然存在服务器
3. 每个用户，需要分配一个容器

​		这个技术，就是session：**存储用户多次请求过程中的数据**

​		跟cookie有区别——cookie存数据（用户名称，用户密码：身份验证数据）  session 存数据（普通业务内容），总结：

1. session是服务器开辟的一个用来存储数据的空间
2. 服务器为每个浏览器单独开辟一个session
3. 服务器根据浏览器发送过来的cookie，来确认当前浏览器使用哪个session

​		除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以**利用 Session 存储在服务器端，存储在服务器端的信息更加安全。**

​		**Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。**

​		使用 Session 维护用户登录状态的过程如下：

- 用户进行登录时，**用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；**
- **服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；**
- 服务器返回的**响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；**
- **客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息**，继续之前的业务操作。

​		应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，**还需要经常重新生成 Session ID**。在对安全性要求极高的场景下，例如转账等操作，**除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式**。

### （7）浏览器禁用Cookie

​		此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，**不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。**

### （8）Cookie和Session区别

- **Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据**，因此在考虑数据复杂性时首选 Session；

- **Cookie 存储在浏览器中，容易被恶意查看**。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；

- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

- Cookie 在客户端（浏览器），Session 在服务器端。

- 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。

- **Cookie是把用户的数据写给用户的浏览器。**

  **Session技术把用户的数据写到用户独占的session中（服务器端）。**

# 三、HTTP首部

## 1.HTTP报文

​		用于HTTP协议交互的信息被称为HTTP报文。HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

![image-20210323205753187](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323205753187.png)

## 2.请求报文及响应报文的结构

![image-20210323205848356](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323205848356.png)

- 请求行：包含用于请求的方法，请求URI和HTTP版本。

- 状态行：包含表明响应结果的状态码、原因短语和HTTP版本。

- 首部字段：包含请求和响应的各种条件和属性的各类首部。

  ​					一般有4种首部：请求首部、响应首部、通用首部和实体首部。

- 其他：可能包含HTTP的RFC里未定义的首部（Cookie等）。

# 四、HTTP状态码

​		服务器返回的**响应报文**中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。数字中第一位指定了响应类别，后两位无分类。

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

## 1.1XX信息

- **100Continue**：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

## 2.2XX成功

​		2XX的响应结果表明请求被正常处理了。

- **200 OK**：表示从客户端发来的请求在服务器端被正常处理了。在响应报文中，随状态码一起返回的信息会因为方法的不同而发生改变。例如。GET方法会返回对应请求资源的实体，而HEAD方法只返回首部，不返回实体的主体部分。

- **204 No Content**：表示服务器接收的请求已经成功处理，但在返回的响应报文中不含实体的主体部分。**另外，也不允许返回任何实体的主体。**

  一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

- **206 Partial Content**：该状态码表示**客户端进行了范围请求，而服务器成功执行了这部分的GET请求。**响应报文中包含由Content-Range指定范围的实体内容。

## 3.3XX重定向

​		3XX响应结果表明浏览器需要执行某些特殊的操作以正确处理请求。

- **301 Moved Permanently**：永久性重定向。该状态码表示请求的资源已被分配了新的URI，**以后应使用现在资源所指的URI。**

- **302 Found**：临时性重定向。该状态码表示请求的资源已被分配了新的URI，**希望用户（本次）能使用新的URI访问。**

  和301状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI。

- **303 See Other**：该状态码表示由于请求对应的资源**存在着另一个URI**，应使用**GET方法定向获取请求的资源。**

  303状态码和302Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这与302状态码有区别。

> ​		当301、302、303响应状态码返回时，**几乎所有浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。**
>
> ​		301、302标准是禁止将POST方法改成GET方法的，但实际使用时大家都会这么做。

- **304 Not Modified**：该状态码表示客户端发送附带条件的请求（例如If-Match，If-Range等）时，服务器端允许请求访问资源，但未满足条件的情况。**304状态码返回时，不包含任何响应的主体部分。**304和重定向没有关系。
- **307 Temporary Redirect**：

## 4.4XX客户端错误

​		4XX的响应结果表明客户端是发生错误的原因所在。

- **400 Bad Request**：该状态码表示请求报文中存在语法错误。另外，浏览器会像200 OK一样对待该状态码。
- **401 Unauthorized**：该状态码表示发送的请求需要有通过HTTP的认证信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。若服务器端再次收到1次请求，则表示用户认证失败。

![image-20210323213545389](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210323213545389.png)

- **403 Forbidden**：该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但若想说明，可以在实体的主体部分对原因进行描述，这样用户就可以看到了。
- **404 Not Found**：该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求并且不想说明理由时使用。

## 5.5XX服务器错误

​		5XX的响应结果表示服务器本身发生错误。

- **500 Internal Server Error**：该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。

- **503 Service Unavailable**：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。**若事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。**

> 状态码和状况的不一致：不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK。

# 五、具体应用

## 1.缓存

​		缓存是指**代理服务器或客户端本地磁盘内保存的资源副本**。利用缓存可减少对源服务器的访问，可以节省通信流量和通信时间。

### （1）优点

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

### （2）实现方法

- 让代理服务器进行缓存
- 让客户端浏览器进行缓存

### （3）Cache-Control

​		HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

- **禁止进行缓存**：当使用no-store时，暗示请求和对应的响应或响应中包含机密信息，因此no-store 指令规定不能对请求或响应的任何一部分进行缓存。

  ```
  Cache-Control: no-store
  ```

- **强制确认缓存**：

  使用no-cache指令的目的是为了防止从缓存中返回过期的资源。

  客户端发送的请求中如果包含no-cache指令，则表示**客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。**
  如果服务器返回的响应中包含no-cache指令，那么**缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。**

  由服务器返回的响应中，**若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。**换言之，**无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数**。

  **即源服务器通知客户端/缓存服务器，不要缓存响应报文中的Location字段，其他的可以缓存。**

  ```
  Cache-Control: no-cache=Location
  ```

- **私有缓存和公共缓存**：

  private 指令规定了将资源作为私有缓存，**只能被单独用户使用**，一般存储在**用户浏览器**中。

  ```
  Cache-Control: private
  ```

  public 指令规定了将资源作为公共缓存，**可以被多个用户使用**，一般存储在**代理服务器**中。

  ```
  Cache-Control: public
  ```

- **缓存过期机制**：

  max-age 指令出现在**请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。**另外，当指定max-age=0时，缓存服务器通常需要将请求转发给源服务器。

  max-age 指令出现在**响应报文，表示缓存资源在缓存服务器中保存的时间。**

  ```
  Cache-Control: max-age=31536000
  ```

  Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。

  ```
  Expires: Wed, 04 Jul 2012 08:26:05 GMT
  ```

  - 在 HTTP/1.1 中，会优先处理 max-age 指令，忽略掉Expires首部字段；
  - 在 HTTP/1.0 中，情况相反，max-age 指令会被忽略掉。

### （4）缓存验证

​		响应首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做**唯一性标识**的方式。服务器会为每份资源分配对应的ETag值。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。

​		可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

​		**Last-Modified 首部字段也可以用于缓存验证**，它包含在**源服务器发送的响应报文中**，指示源服务器对资源的最后修改时间。**但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息。**

​		**客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。**服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。

## 2.内容协商

​		通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

### （1）类型

#### ①服务端驱动型

​		客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。

他存在以下问题：

- **服务器很难知道客户端浏览器的全部信息**；
- **客户端提供的信息相当冗长**（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
- **给定的资源需要返回不同的展现形式**，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

#### ②代理驱动型

​		服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

### （2）Vary

​		在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

​		例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

## 3.内容编码

​		内容编码将实体主体进行压缩，从而减少传输的数据量。

​		常用的内容编码有：gzip、compress、deflate、identity。

​		浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。

## 4.范围请求

​		如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

### （1）Range

​		在请求报文中添加 Range 首部字段指定请求的范围。

​		请求成功的话服务器返回的响应包含 206 Partial Content 状态码。无法处理该范围请求时，则会返回状态码200 OK的响应及全部资源。

### （2）Accept-Ranges

​		响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

### （3）响应状态码

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

## 5.分块传输编码

​		Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。

## 6.多部分对象集合

​		一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。

​		例如，上传多个表单时可以使用如下方式：

```
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

## 7.虚拟主机

​		HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。

​		在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，**因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。**

## 8.通信数据转发

### （1）代理

​		代理服务器接受客户端的请求，并且转发给其它服务器。

​		使用代理的主要目的是：

- 缓存

- 负载均衡

- 网络访问控制

- 访问日志记录

  代理服务器分为正向代理和反向代理两种：

- 用户察觉得到正向代理的存在。

![image-20210324201418115](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210324201418115.png)

- 而反向代理一般位于内部网络中，用户察觉不到。

![image-20210324201433488](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210324201433488.png)

​		正向代理是客户端和其他所有服务器（重点：所有）的代理者，而反向代理是客户端和反向代理服务器所代理的服务器之间的代理（也就是说反向代理有可能代理2个服务器，3个服务器等）。

​		一般的正向代理，比如翻墙，任何可以连接到该代理服务器的软件，就可以通过代理访问任何的其他服务器，然后把数据返回给客户端，这里代理服务器只对客户端负责。而反向代理的话，如果他反向代理了两个服务，那么之后客户端访问这两个服务器的时候，该代理服务器才会给它代理，也就是说，这里的代理服务器只对该代理服务器所代理的服务器负责。

### （2）网关

​		与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。

### （3）隧道

​		使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。

# 六、HTTPS（HTTP+加密+认证+完整性保护）

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

​		HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

​		SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。

​		通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

## 1.加密

### （1）对称密钥加密（共享密钥加密）

​		加密和解密共用一个密钥的方式称为对称密钥加密。

​		但发送密钥就有被窃听的风险，但不发送，对方就不能解密。再说，若密钥能够安全发送，数据也应该可以安全送达。

- 优点：运算速度快：
- 缺点：无法安全地将密钥传输给通信方。

![image-20210324213221685](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210324213221685.png)

### （2）非对称密钥加密（公开密钥加密）

​		公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。

​		公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

​		非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

![image-20210324213252513](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210324213252513.png)

### （3）HTTPS采用混合加密机制

​		上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

![image-20210324213600859](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210324213600859.png)

## 2.认证

​		公开密钥加密还是存在一些问题：无法证明密钥本身就是货真价实的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。

​		为了解决上述问题，可以使用由数字证书认证机构和其相关机关颁发的公开密钥证书。

​		数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

​		服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

​		**进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。**![image-20210325002253320](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210325002253320.png)

## 3.完整性保护

​		**SSL 提供报文摘要功能来进行完整性保护。**

​		HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

​		**HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。**试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

## 4.HTTPS的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

# 七、HTTP/2.0

## 1.HTTP/1.x缺陷

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要**使用多个连接才能实现并发和缩短延迟；**
- **不会压缩请求和响应首部**，从而导致不必要的网络流量；
- **不支持有效的资源优先级**，致使底层 TCP 连接的利用率低下。

## 2.二进制分帧层

​		HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

![image-20210325003917865](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210325003917865.png)

​		在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都**有一个唯一标识符和可选的优先级信息**，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

![image-20210325004016212](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210325004016212.png)

## 3.服务端推送

​		HTTP/2.0 在客户端请求一个资源时，**会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。**例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

## 4.首部压缩

​		HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

​		**HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。**

​		**不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。**

![image-20210325004300714](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210325004300714.png)

# 八、HTTP/1.1 新特性

- 默认是**长连接**
- **支持流水线**
- 支持**同时打开多个 TCP 连接**
- 支持**虚拟主机**
- 新增状态码 100
- **支持分块传输编码**
- **新增缓存处理指令 max-age**
- 范围请求

# 九、GET 和 POST 比较

- GET 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 POST 参数放在请求主体中，并且参数不会被保留，**相比GET方法，POST 方法更安全，主要用于修改服务器上的资源。**

- **GET请求只支持 URL 编码，POST 请求支持多种编码格式。**

- **GET 只支持 ASCII 字符格式的参数，而POST方法没有限制。**

- GET 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 POST方法提交的数据没限制

- GET方法产生一个 TCP 数据包，POST方法产生两个（并不是所有的浏览器中都产生两个）。

- **对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。**

  **对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再POST发送一个data给服务端，服务端响应200，请求成功。**