

# 一、UML

​		统一建模语言UML

​		UML箭头方向：**从子类指向父类**。

## 1.UML类图

### （1）实线-继承|虚线-实现

​		空心三角箭头：继承或实现。

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718173353372.png" alt="image-20210718173353372" style="zoom: 50%;" />

### （2）实线-关联|虚线-依赖

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718173852787.png" alt="image-20210718173852787" style="zoom:50%;" />

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718173740359.png" alt="image-20210718173740359" style="zoom:50%;" />

### （3）空心菱形-聚合|实心菱形-组合

​		聚合：整体与部分的关系，且部分可以离开整体而单独存在。生命周期各自独立。如车和轮胎是聚合关系，轮胎离开车仍然可以存在。

​		组合：整体与部分的关系，但部分不能离开整体而单独存在。同生同灭。如公司和部门是组合关系，没有公司就不存在部门。

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718174158000.png" alt="image-20210718174158000" style="zoom:50%;" />

​		常见数字表达及含义，假设有A类和B类，数字标记在A类侧：

- 0..1:B实例可以与0个或1个A实例相关
- 0..*:B实例可以与0个或多个A实例相关
- 1..1:B实例可以与1个A实例相关
- 1:B实例可以与1个A实例相关
- 1..*:B实例可以与1个或多个A实例相关

### （4）类图详解

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718190838593.png" alt="image-20210718190838593" style="zoom:50%;" />

+:public

-:private

\#:protected

~:default

下划线：static

正体：普通方法/普通类

斜体：抽象方法/抽象类

PS：因为有抽象方法`+study()`,所以本类应该是抽象类，不应为正体，而应为斜体*GeelyClass*。

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718193656152.png" alt="image-20210718193656152" style="zoom: 70%;" />

## 2.UML时序图

​		是显示对象之间交互的图，这些对象是按时间顺序排列的。

​		时序图中包括的建模元素主要有：对象、生命线、控制焦点、消息等。

![image-20210718185518648](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718185518648.png)

# 二、软件设计七大原则

## 1.开闭原则

- 定义：一个软件实体如类、模块和函数应该**对扩展开放，对修改关闭**。用抽象构建框架，用实现扩展细节。
- 优点：提高软件系统的可复用性及可维护性。

![image-20210718231924248](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718231924248.png)

## 2.依赖倒置原则

- 定义：高层模块不应该依赖底层模块，二者都应该依赖其抽象。
- 抽象不应该依赖细节；细节应该依赖抽象。
- **针对接口编程**，不要针对实现编程。
- 优点：可以减少类间的耦合性，提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险。

![image-20210718231847735](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210718231847735.png)

> v2——参数方法
>
> v4——构造器方法

## 3.单一职责原则

- 定义：不要存在多于一个导致类变更的原因。
- 一个类/接口/方法只负责一项职责。
- 优点：降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。

![image-20210719002758386](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210719002758386.png)

## 4.接口隔离原则

- 定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口
- 一个类对一个类的依赖应该建立在最小的接口上
- 建立单一接口，不要建立庞大的接口
- 尽量细化接口，接口中的方法尽量少
- 一定要适度
- 优点：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性

![image-20210719220405204](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210719220405204.png)

## 5.迪米特原则

- 定义：一个对象应该对其他对象保持最少的了解，又称最少知道原则。
- 强调只和朋友交流，不和陌生人说话
  - 朋友类指出现在成员变量、方法的输入、输出参数中的类，而**出现在方法体内部的类不属于朋友类。**
- 优点：降低类之间的耦合

![image-20210719224605332](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210719224605332.png)

## 6.里式替换原则

- 定义：如果对每一个类型为 T1 的对象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。
- 可以理解为一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变
- 引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类中可以增加自己特有的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
  - 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。

- 优点：
  - 约束继承泛滥，开闭原则的一种体现。
  - 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。

![image-20210719230950116](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210719230950116.png)

## 7.合成复用原则

- 定义：尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。
- 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。

![image-20210719232410748](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210719232410748.png)

# 三、创建型模式

## 0.简单工厂 （不属于GOF23种设计模式）

- 定义：由一个工厂对象决定创建出哪一种产品类的实例

- 适用场景
  - 工厂类负责创建的对象比较少
  - 应用层只知道传入工厂类的参数，对于如何创建对象不关心
  
- 优点：只需要传入一个正确的参数，就可以获取所需要的对象，而无需知道其创建细节

- 缺点：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则，且无法形成基于继承的等级结构。

  ​		Video:

  ```java
  public abstract class Video {
      public abstract void produce();
  }
  ```

  ​		JavaVideo:

  ```java
  public class JavaVideo extends Video{
      @Override
      public void produce() {
          System.out.println("Java视频");
      }
  }
  ```

  ​		PythonVideo:

  ```java
  public class PythonVideo extends Video{
      @Override
      public void produce() {
          System.out.println("Python视频");
      }
  }
  ```

  ​		VideoFactory:

  ```java
  public class VideoFactory {
      //新增课程后，无需修改工厂
      public Video getVideo(Class c) {
          Video video = null;
          try {
              video = (Video) Class.forName(c.getName()).newInstance();
          } catch (InstantiationException e) {
              e.printStackTrace();
          } catch (IllegalAccessException e) {
              e.printStackTrace();
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
          return video;
          //Calendar
      }
  
  
      //v1
      /*public Video getVideo(String type) {
          if ("java".equalsIgnoreCase(type)) {
              return new JavaVideo();
          } else if ("python".equalsIgnoreCase(type)) {
              return new PythonVideo();
          }
          return null;
      }*/
  }
  ```

  ​		Test:

  ```java
  public class Test {
  
      public static void main(String[] args) {
          VideoFactory videoFactory = new VideoFactory();
          Video video = videoFactory.getVideo(JavaVideo.class);
          if (video == null) {
              return;
          }
          video.produce();
      }
  
      //v1
      /*public static void main(String[] args) {
          VideoFactory videoFactory = new VideoFactory();
          Video video = videoFactory.getVideo("java");
          if (video == null) {
              return;
          }
          video.produce();
      }*/
  }
  ```

  ![image-20210720012108106](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210720012108106.png)

  > 源码：`java.util.Calendar`

## 1.工厂方法模式

- 定义：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，**工厂方法让类的实例化推迟到子类中进行**
- 适用场景：
  - 创建对象需要大量重复的代码
  - 客户端不依赖于产品类如何被创建、实现等细节
  - 一个类通过其子类来制定创建哪个对象
- 优点：
  - 用户只需要关心所需产品对应的工厂，无需关心创建细节
  - 加入新产品符合开闭原则，提高可扩展性
- 缺点：
  - 类的个数容易过多
  - 增加了系统的抽象性和理解难度

​		Video:

```java
public abstract class Video {
    public abstract void produce();
}
```

​		JavaVideo:

```java
public class JavaVideo extends Video{
    @Override
    public void produce() {
        System.out.println("Java视频");
    }
}
```

​		PythonVideo:

```java
public class PythonVideo extends Video{
    @Override
    public void produce() {
        System.out.println("Python视频");
    }
}
```

​		FEVideo:

```java
public class FEVideo extends Video{
    @Override
    public void produce() {
        System.out.println("FE视频");
    }
}
```

​		VideoFactory:

```java
public abstract class VideoFactory {
    public abstract Video getVideo();
}
```

​		JavaVideoFactory:

```java
public class JavaVideoFactory extends VideoFactory{
    @Override
    public Video getVideo() {
        return new JavaVideo();
    }
}
```

​		PythonVideoFactory:

```java
public class PythonVideoFactory extends VideoFactory{
    @Override
    public Video getVideo() {
        return new PythonVideo();
    }
}
```

​		FEVideoFactory:

```java
public class FEVideoFactory extends VideoFactory{
    @Override
    public Video getVideo() {
        return new FEVideo();
    }
}
```

​		Test:

```java
public class Test {
    public static void main(String[] args) {
        VideoFactory videoFactory = new JavaVideoFactory();
        VideoFactory videoFactory2 = new PythonVideoFactory();
        VideoFactory videoFactory3 = new FEVideoFactory();
        Video video = videoFactory.getVideo();
        video.produce();
        video = videoFactory2.getVideo();
        video.produce();
        video = videoFactory3.getVideo();
        video.produce();
    }
}
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721184716262.png" alt="image-20210721184716262" style="zoom: 67%;" />

> 源码：java.net.URLStreamHandlerFactory 
>
> ​	   	sun.misc.Launcher
>
> ​		   sun.net.www.protocol.http
>
> ​		   URLStreamHandlerFactory→VideoFactory
>
> ​		   Factory→**VideoFactory
>
> ​		   URLStreamHandler→Video
>
> ​		   Handler→**Video

## 2.抽象工厂模式

- 定义：提供一个创建**一系列相关或相互依赖对象的接口**，无需指定它们具体的类
- 适用场景：
  - 客户端不依赖于产品类如何被创建、实现等细节
  - 强调**一系列相关的产品对象**（属于同一产品族）**一起使用创建对象需要大量重复的代码**
  - 提供一个产品类的库，**所有的产品以同样的接口出现**，从而使**客户端不依赖于具体实现**
- 优点：
  - 具体产品在应用层代码隔离，无需关心创建细节
  - 将一个系列的产品族统一到一起创建
- 缺点：
  - 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
  - 增加了系统的抽象性和理解难度
  - **扩展产品族容易，但是扩展产品等级会很麻烦**，比如以及有了Java和Python视频和笔记，再加一个前端的视频和笔记是方便的，但是增加一个新的源码项的话会很麻烦，会更改具体实现。
- 对比：
  - **工厂方法：确定产品等级结构（比如都是空调）**
  - **抽象工厂：确定产品族（比如都是美的的产品）**
  - 从高层次来看，**抽象工厂使用了组合**，即 Cilent 组合了 AbstractFactory，而**工厂方法模式使用了继承**。

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210720213532091.png" alt="image-20210720213532091" style="zoom:50%;" />

​		Article:

```java
public abstract class Article {
    public abstract void produce();
}
```

​		JavaArticle:

```java
public class JavaArticle extends Article{
    @Override
    public void produce() {
        System.out.println("Java手记");
    }
}
```

​		PythonArticle:

```java
public class PythonArticle extends Article{
    @Override
    public void produce() {
        System.out.println("Python手记");
    }
}
```

​		Video:

```java
public abstract class Video {
    public abstract void produce();
}
```

​		JavaVideo:

```java
public class JavaVideo extends Video{
    @Override
    public void produce() {
        System.out.println("Java视频");
    }
}
```

​		PythonVideo:

```java
public class PythonVideo extends Video{
    @Override
    public void produce() {
        System.out.println("Python视频");
    }
}
```

​		CourseFactory:

```java
public interface CourseFactory {
    Video getVideo();

    Article getArticle();
}

```

​		JavaCourseFactory:

```java
public class JavaCourseFactory implements CourseFactory{
    @Override
    public Video getVideo() {
        return new JavaVideo();
    }

    @Override
    public Article getArticle() {
        return new JavaArticle();
    }
}
```

​		PythonCourseFactory:

```java
public class PythonCourseFactory implements CourseFactory{
    @Override
    public Video getVideo() {
        return new PythonVideo();
    }

    @Override
    public Article getArticle() {
        return new PythonArticle();
    }
}
```

​		Test:

```java
public class Test {
    public static void main(String[] args) {
        CourseFactory courseFactory = new JavaCourseFactory();
        Video video = courseFactory.getVideo();
        Article article = courseFactory.getArticle();
        video.produce();
        article.produce();
    }
}
```



<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721184758749.png" alt="image-20210721184758749" style="zoom:67%;" />

## 3.建造者模式

- 定义：将一个复杂对象的构建与它的表示分离，**使得同样的构建过程可以创建不同的表示**。
- 用户只需指定需要建造的类型就可以得到它们，建造过程及细节无需知道。
- 适用场景：
  - 一个对象有**非常复杂的内部结构**（很多属性）
  - 想把复杂对象的创建和使用分离
- 优点：
  - 封装性好，创建和使用分离
  - 扩展性好，建造类之间独立，一定程度上解耦
- 缺点：
  - 产生多余的Builder对象
  - 产品内部发生变化，建造者都要修改，成本较大
- 与工厂方法区别：
  - 建造者模式**注重方法的调用顺序**，可以创建复杂的产品，不只需要创建出产品，还需要产品由哪些部件组成
  - 工厂方法**注重创建产品**，且都是相同的产品，只要成功创建即可

### （1）v1

​		Course:

```java
public class Course {
    private String courseName;
    private String coursePPT;
    private String courseVideo;
    private String courseArticle;
    private String courseQA;

    public String getCourseName() {
        return courseName;
    }

    public void setCourseName(String courseName) {
        this.courseName = courseName;
    }

    public String getCoursePPT() {
        return coursePPT;
    }

    public void setCoursePPT(String coursePPT) {
        this.coursePPT = coursePPT;
    }

    public String getCourseVideo() {
        return courseVideo;
    }

    public void setCourseVideo(String courseVideo) {
        this.courseVideo = courseVideo;
    }

    public String getCourseArticle() {
        return courseArticle;
    }

    public void setCourseArticle(String courseArticle) {
        this.courseArticle = courseArticle;
    }

    public String getCourseQA() {
        return courseQA;
    }

    public void setCourseQA(String courseQA) {
        this.courseQA = courseQA;
    }

    @Override
    public String toString() {
        return "Course{" +
                "courseName='" + courseName + '\'' +
                ", coursePPT='" + coursePPT + '\'' +
                ", courseVideo='" + courseVideo + '\'' +
                ", courseArticle='" + courseArticle + '\'' +
                ", courseQA='" + courseQA + '\'' +
                '}';
    }
}
```

​		CourseBuilder:

```java
public abstract class CourseBuilder {

    public abstract void buildCourseName(String courseName);
    public abstract void buildCoursePPT(String coursePPT);
    public abstract void buildCourseVideo(String courseVideo);
    public abstract void buildCourseArticle(String courseArticle);
    public abstract void buildCourseQA(String courseQA);

    public abstract Course makeCourse();
}
```

​		CourseActualBuilder:

```java
public class CourseActualBuilder extends CourseBuilder{

    private Course course = new Course();

    @Override
    public void buildCourseName(String courseName) {
        course.setCourseName(courseName);
    }

    @Override
    public void buildCoursePPT(String coursePPT) {
        course.setCoursePPT(coursePPT);
    }

    @Override
    public void buildCourseVideo(String courseVideo) {
        course.setCourseVideo(courseVideo);
    }

    @Override
    public void buildCourseArticle(String courseArticle) {
        course.setCourseArticle(courseArticle);
    }

    @Override
    public void buildCourseQA(String courseQA) {
        course.setCourseQA(courseQA);
    }

    @Override
    public Course makeCourse() {
        return course;
    }
}
```

​		Coach:

```java
public class Coach {
    private CourseBuilder courseBuilder;

    public void setCourseBuilder(CourseBuilder courseBuilder) {
        this.courseBuilder = courseBuilder;
    }

    public Course makeCourse(String courseName,String coursePPT,
                             String courseVideo,String courseArticle,
                             String courseQA){
        this.courseBuilder.buildCourseName(courseName);
        this.courseBuilder.buildCoursePPT(coursePPT);
        this.courseBuilder.buildCourseVideo(courseVideo);
        this.courseBuilder.buildCourseArticle(courseArticle);
        this.courseBuilder.buildCourseQA(courseQA);
        return this.courseBuilder.makeCourse();
    }
}
```

​		Test:

```java
public class Test {
    public static void main(String[] args) {
        CourseBuilder courseBuilder = new CourseActualBuilder();
        Coach coach = new Coach();
        coach.setCourseBuilder(courseBuilder);

        Course course = coach.makeCourse("Java", "JavaPPT", "Java视频", "Java手记", "Java问答");
        System.out.println(course);
    }
}
```

![image-20210721202651068](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721202651068.png)

### （2）v2

​		Course:

```java
public class Course {
    private String courseName;
    private String coursePPT;
    private String courseVideo;
    private String courseArticle;
    private String courseQA;

    public Course(CourseBuilder courseBuilder){
        this.courseName=courseBuilder.courseName;
        this.coursePPT=courseBuilder.coursePPT;
        this.courseVideo=courseBuilder.courseVideo;
        this.courseArticle=courseBuilder.courseArticle;
        this.courseQA=courseBuilder.courseQA;
    }

    @Override
    public String toString() {
        return "Course{" +
                "courseName='" + courseName + '\'' +
                ", coursePPT='" + coursePPT + '\'' +
                ", courseVideo='" + courseVideo + '\'' +
                ", courseArticle='" + courseArticle + '\'' +
                ", courseQA='" + courseQA + '\'' +
                '}';
    }

    public static class CourseBuilder {
        private String courseName;
        private String coursePPT;
        private String courseVideo;
        private String courseArticle;
        private String courseQA;

        public CourseBuilder buildCourseName(String courseName) {
            this.courseName = courseName;
            return this;
        }

        public CourseBuilder buildCoursePPT(String coursePPT) {
            this.coursePPT = coursePPT;
            return this;
        }

        public CourseBuilder buildCourseVideo(String courseVideo) {
            this.courseVideo = courseVideo;
            return this;
        }

        public CourseBuilder buildCourseArticle(String courseArticle) {
            this.courseArticle = courseArticle;
            return this;
        }

        public CourseBuilder buildCourseQA(String courseQA) {
            this.courseQA = courseQA;
            return this;
        }

        public Course build(){
            return new Course(this);
        }
    }
}
```

​		Test:

```java
public class Test {
    public static void main(String[] args) {
        Course course = new Course.CourseBuilder().buildCourseName("Java课程").buildCoursePPT("JavaPPT").buildCourseVideo("Java视频").build();
        System.out.println(course);
    }
}
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721202658538.png" alt="image-20210721202658538" style="zoom:50%;" />

> 源码：java.lang.StringBuilder

## 4.单例模式

- 定义：**保证一个类仅有一个实例，并提供一个全局访问点**
- 适用场景：想确保任何情况下都**绝对只有一个实例**
- 优点：
  - 在内存里只有一个实例，减少了内存开销
  - 可以避免对资源的多重占用
  - 设置全局访问点，严格控制访问
- 缺点：
  - 没有接口，扩展困难
- 重点：
  - **私有构造器**
  - **线程安全**
  - 延迟加载
  - 序列化和反序列化安全
  - 反射

### （1）懒汉式

#### ①线程不安全

```java
public class LazySingleton {
    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public static LazySingleton getInstance() {
        //两个线程同时到达这里时，可能会多次创建实例，就不符合单例要求
        if (lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}
```

#### ②线程安全（效率低）

```java
public class LazySingleton {
    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public synchronized static LazySingleton getInstance() {
        if (lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
    
    //因为是静态方法，两种写法等价
    /*public static LazySingleton getInstance() {
        synchronized (LazySingleton.class){
            if (lazySingleton == null) {
                lazySingleton = new LazySingleton();
            }
            return lazySingleton;
        }
    }*/
}
```

#### ③线程不安全

```java
public class LazySingleton {
    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            //两个线程同时到达这里时，可能会多次创建实例，就不符合单例要求
            synchronized (LazySingleton.class){
                lazySingleton = new LazySingleton();
            }
        }
        return lazySingleton;
    }
}
```

### （2）※双重检查——禁止重排序

```java
public class LazyDoubleCheckSingleton {
    private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null;

    private LazyDoubleCheckSingleton() {

    }

    public static LazyDoubleCheckSingleton getInstance() {
        //两个线程同时到达这里时，可能会多次创建实例，就不符合单例要求
        if (lazyDoubleCheckSingleton == null) {
            synchronized (LazyDoubleCheckSingleton.class) {
                if (lazyDoubleCheckSingleton == null) {
                    lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();
                    //1.给对象分配内存
                    //2.对象初始化
                    //3.设置lazyDoubleCheckSingleton指向刚分配的内存地址
                }
            }
        }
        return lazyDoubleCheckSingleton;
    }
}
```

- 为什么要double-check

  - **线程安全**
  - **单check不行，会多次创建实例**
  - **synchronized方法不行，要考虑性能问题**

- 为什么要用volatile

  - 新建对象实际上有3个步骤，并非原子操作，很可能产生重排序（以下为正常顺序）：

    1. 创建空对象
    2. 调用构造方法
    3. 将实例赋值给引用

  - **防止重排序**

  - **重排序会带来NPE（空指针异常）**

    单线程时步骤2和步骤3的重排序不会影响最终步骤4的访问，但是在多线程中会影响其他线程的判断。

    <img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721231851598.png" alt="image-20210721231851598" style="zoom:33%;" />

    <img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721231240893.png" alt="image-20210721231240893" style="zoom: 33%;" />

### （3）静态内部类——基于类初始化的延迟加载解决方案

```java
public class StaticInnerClassSingleton {

    private StaticInnerClassSingleton() {

    }

    private static class InnerClass {
        //JVM类的加载的性质保证即使多个线程同时访问，也不会创建多个实例
        private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton();
    }

    public static StaticInnerClassSingleton getInstance() {
        return InnerClass.staticInnerClassSingleton;
    }
}
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210721232505891.png" alt="image-20210721232505891" style="zoom: 33%;" />

### （4）饿汉式

#### ①静态常量

```java
public class HungrySingleton {
    private final static HungrySingleton hungrySingleton = new HungrySingleton();

    private HungrySingleton() {
        
    }
    
    public static HungrySingleton getInstance(){
        return hungrySingleton;
    }
}
```

#### ②静态代码块

```java
public class HungrySingleton {
    private final static HungrySingleton hungrySingleton;

    static {
        hungrySingleton = new HungrySingleton();
    }
    
    private HungrySingleton() {

    }

    public static HungrySingleton getInstance(){
        return hungrySingleton;
    }
}
```

### （5）序列化破坏单例模式

​		当我们使用序列化，将实例写入文件之后再读取，读取前后的两个实例不相同，这是因为ObjectInputStream读取后创建对象是通过**反射机制**，而这不是我们想要的结果。

​		HungrySingleton:

```java
public class HungrySingleton implements Serializable {
    private final static HungrySingleton hungrySingleton;

    static {
        hungrySingleton = new HungrySingleton();
    }

    private HungrySingleton() {

    }

    public static HungrySingleton getInstance(){
        return hungrySingleton;
    }
}
```

​		Test:

```java
public class Test implements Serializable{
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        HungrySingleton instance = HungrySingleton.getInstance();
        File file = new File("singleton_file");

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
        oos.writeObject(instance);

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        HungrySingleton newInstance = (HungrySingleton) ois.readObject();

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance==newInstance);
    }
}

com.uranus.design.pattern.creational.singleton.HungrySingleton@4dd8dc3
com.uranus.design.pattern.creational.singleton.HungrySingleton@69d0a921
false
```

​		在HungrySingleton中添加如下代码后，显示结果如下：

```java
private Object readResolve() {
        return hungrySingleton;
}

com.uranus.design.pattern.creational.singleton.HungrySingleton@4dd8dc3
com.uranus.design.pattern.creational.singleton.HungrySingleton@4dd8dc3
true
```

### （6）反射攻击

​		Test:

```java
public class Test implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class objectClass = HungrySingleton.class;
        //等价写法
        //Class objectClass = Class.forName(HungrySingleton.class.getName());
        
        Constructor constructor = objectClass.getDeclaredConstructor();
        constructor.setAccessible(true);//通过反射机制更改权限
        HungrySingleton instance = HungrySingleton.getInstance();
        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();//直接调用了私有构造器

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance==newInstance);
    }
}
```

​		将HungrySingleton的私有构造器更改为如下代码后，可成功做到反射防御：

```java
private HungrySingleton() {
    if(hungrySingleton!=null){
        throw new RuntimeException("单例构造器禁止反射调用");
    }
}
```

​		除了HungrySingleton以外，**这种方式对于在类加载时就已经将对象创建好的单例模式均适用**，例如**静态内部类**。

​		对于不在类加载时就将对象创建好的单例模式，例如LazySingleton，若采用上述方法防御反射，交换以下代码顺序会导致方法失效。

​		后调用构造器：

```java
LazySingleton instance = LazySingleton.getInstance();
LazySingleton newInstance = (LazySingleton) constructor.newInstance();

Exception in thread "main" java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at com.uranus.design.pattern.creational.singleton.Test.main(Test.java:16)
Caused by: java.lang.RuntimeException: 单例构造器禁止反射调用
	at com.uranus.design.pattern.creational.singleton.LazySingleton.<init>(LazySingleton.java:8)
	... 5 more
```

​		先调用构造器——方法失效：

```Java
LazySingleton newInstance = (LazySingleton) constructor.newInstance();
LazySingleton instance = LazySingleton.getInstance();

com.uranus.design.pattern.creational.singleton.LazySingleton@13221655
com.uranus.design.pattern.creational.singleton.LazySingleton@2f2c9b19
false
```

​		此时可以对LazySingleton的构造函数做以下更改：

```java
private static boolean flag = true;

private LazySingleton() {
	synchronized (LazySingleton.class) {
        if (flag) {
            flag = !flag;
        } else {
            throw new RuntimeException("单例构造器禁止反射调用");
        }
    }
}
```

​		但此时仍然使用反射就可以更改flag的值，使flag失效：

```java
LazySingleton instance = LazySingleton.getInstance();
Field field = instance.getClass().getDeclaredField("flag");
field.setAccessible(true);
field.set(instance,true);
LazySingleton newInstance = (LazySingleton) constructor.newInstance();//直接调用了私有构造器
```

### （7）※Enum枚举

- **写法简单**
- **线程安全有保障**
- **避免反序列化破坏单例**

#### ①有效防范序列化

​		EnumInstance：

```java
public enum EnumInstance {
    INSTANCE;
    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumInstance getInstance(){
        return INSTANCE;
    }
}
```

​		Test：

```java
public class Test implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        EnumInstance instance = EnumInstance.getInstance();
        instance.setData(new Object());
        File file = new File("singleton_file");

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
        oos.writeObject(instance);

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        EnumInstance newInstance = (EnumInstance) ois.readObject();

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance==newInstance);
        System.out.println(instance.getData());
        System.out.println(newInstance.getData());
        System.out.println(instance.getData()==newInstance.getData());
    }
}

INSTANCE
INSTANCE
true
java.lang.Object@238e0d81
java.lang.Object@238e0d81
true
```

#### ②有效防范反射

​		Test：

```java
public class Test implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        Class objectClass = EnumInstance.class;
        //等价写法
        //Class objectClass = Class.forName(HungrySingleton.class.getName());

        Constructor constructor = objectClass.getDeclaredConstructor(String.class,int.class);
        constructor.setAccessible(true);//通过反射机制更改权限
        EnumInstance instance = (EnumInstance) constructor.newInstance("uranus",1);

    }
}

会报错：无法通过反射创建枚举类
```

#### ③方法调用

​		EnumInstance：

```java
public enum EnumInstance {
    INSTANCE{
        protected void printTest(){
            System.out.println("uranus print test");
        }
    };
    protected abstract void printTest();
    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumInstance getInstance(){
        return INSTANCE;
    }
}
```

​		Test：

```java
public class Test implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        EnumInstance instance = EnumInstance.getInstance();
        instance.printTest();
    }
}

uranus print test
```

### （8）容器单例

​		T:

```java
public class T implements Runnable {

    @Override
    public void run() {
        ContainerSingleton.putInstance("object",new Object());
        Object instance = ContainerSingleton.getInstance("object");
        System.out.println(Thread.currentThread().getName() + "  " + instance);
    }
}
```

​		ContainerSingleton:

```java
public class ContainerSingleton {

    private ContainerSingleton(){

    }
    private static Map<String,Object> singletonMap = new HashMap<String,Object>();
    public static void putInstance(String key,Object instance){
        if(StringUtils.isNotBlank(key)&&instance !=null){
            if(!singletonMap.containsKey(key)){
                singletonMap.put(key, instance);
            }
        }
    }
    public static Object getInstance(String key){
        return singletonMap.get(key);
    }
}
```

​		Test:

```java
public class Test implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        Thread t1 = new Thread(new T());
        Thread t2 = new Thread(new T());
        t1.start();
        t2.start();
        System.out.println("ok");
    }
}

ok
Thread-1  java.lang.Object@281266ef
Thread-0  java.lang.Object@281266ef
```

### （9）ThreadLocal“单例”

​		ThreadLocalInstance：

```java
public class ThreadLocalInstance {
    private static final ThreadLocal<ThreadLocalInstance> threadLocalInstanceThreadLocal
            = new ThreadLocal<ThreadLocalInstance>(){
        @Override
        protected ThreadLocalInstance initialValue(){
            System.out.println("ok");
            return new ThreadLocalInstance();
        }
    };
    private ThreadLocalInstance(){

    }
    public static ThreadLocalInstance getInstance(){
        return threadLocalInstanceThreadLocal.get();
    }
}
```

​		T：

```java
public class T implements Runnable {

    @Override
    public void run() {
        ThreadLocalInstance instance = ThreadLocalInstance.getInstance();
        System.out.println(Thread.currentThread().getName() + "  " + instance);
    }
}
```

​		Test：

```java
public class Test implements Serializable {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        System.out.println("main Thread " + ThreadLocalInstance.getInstance());
        System.out.println("main Thread " + ThreadLocalInstance.getInstance());
        System.out.println("main Thread " + ThreadLocalInstance.getInstance());
        System.out.println("main Thread " + ThreadLocalInstance.getInstance());
        System.out.println("main Thread " + ThreadLocalInstance.getInstance());

        Thread t1 = new Thread(new T());
        Thread t2 = new Thread(new T());
        t1.start();
        t2.start();
        System.out.println("ok");
    }
}

main Thread com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@13221655
main Thread com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@13221655
main Thread com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@13221655
main Thread com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@13221655
main Thread com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@13221655
ok
Thread-0  com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@639d6e54
Thread-1  com.uranus.design.pattern.creational.singleton.ThreadLocalInstance@238eb394
```

​		对于多线程资源共享的问题：

- synchronized：以时间换空间，需要排队；

- ThreadLocal：以空间换时间，**它会至少在一个线程里创建一个对象，但这些线程去获取的这个对象是唯一的**，正如上面程序执行结果所示，main线程调用的对象都是一致的。因此在多线程进行访问的时候，彼此不会相互影响。

>  源码：java.lang.Runtime#getRuntime()
> 			 java.awt.Desktop#getDesktop()

## 5.原型模式

- 定义：指原型实例指定创建对象的种类，并且**通过拷贝这些原型创建新的对象**。
- 适用场景：
  - 类初始化消耗较多资源
  - new产生一个对象需要非常繁琐的过程（数据准备、访问权限等）
  - 构造函数比较复杂
  - 循环体中生产大量对象时
- 优点：
  - 原型模式性能比直接new一个对象性能高
  - 简化创建过程
- 缺点
  - 必须配备克隆方法
  - 对克隆复杂对象或对克隆出的对象进行复杂改造时，容易陷入风险
  - 深拷贝、浅拷贝要运用得当
- 扩展：
  - 深拷贝
  - 浅拷贝

### （1）实现Cloneable接口

​		Mail：

```java
public class Mail {
    private String name;
    private String emailAddress;
    private String content;

    public Mail(){
        System.out.println("Mail Class Constructor");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmailAddress() {
        return emailAddress;
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return "Mail{" +
                "name='" + name + '\'' +
                ", emailAddress='" + emailAddress + '\'' +
                ", content='" + content + '\'' +
                '}';
    }
}
```

​		MailUtil：

```java
public class MailUtil {
    public static void sendMail(Mail mail) {
        String outputContent = "向{0}同学，邮件地址：{1}，邮件内容：{2}发送邮件";
        System.out.println(MessageFormat.format(outputContent, mail.getName(), mail.getEmailAddress(), mail.getContent()));
    }

    public static void saveOriginMailRecord(Mail mail) {
        System.out.println("存储originMail记录，originMail：" + mail.getContent());
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Mail mail = new Mail();
        mail.setContent("初始化模板");

        for (int i = 0; i < 10; i++) {
            mail.setName("姓名" + i);
            mail.setEmailAddress("姓名" + i + "@qq.com");
            mail.setContent("hello:" + i);
            MailUtil.sendMail(mail);
        }
        MailUtil.saveOriginMailRecord(mail);
    }
}

Mail Class Constructor
向姓名0同学，邮件地址：姓名0@qq.com，邮件内容：hello:0发送邮件
向姓名1同学，邮件地址：姓名1@qq.com，邮件内容：hello:1发送邮件
向姓名2同学，邮件地址：姓名2@qq.com，邮件内容：hello:2发送邮件
向姓名3同学，邮件地址：姓名3@qq.com，邮件内容：hello:3发送邮件
向姓名4同学，邮件地址：姓名4@qq.com，邮件内容：hello:4发送邮件
向姓名5同学，邮件地址：姓名5@qq.com，邮件内容：hello:5发送邮件
向姓名6同学，邮件地址：姓名6@qq.com，邮件内容：hello:6发送邮件
向姓名7同学，邮件地址：姓名7@qq.com，邮件内容：hello:7发送邮件
向姓名8同学，邮件地址：姓名8@qq.com，邮件内容：hello:8发送邮件
向姓名9同学，邮件地址：姓名9@qq.com，邮件内容：hello:9发送邮件
存储originMail记录，originMail：hello:9
```

​		`MailUtil.saveOriginMailRecord(mail)`是打算存储“初始化模板”的这个mail，但是内容经过for循环后被更改，无法满足业务需求，这就引出原型模板。

​		Mail（实现Cloneable接口）：

```java
package com.uranus.design.pattern.creational.prototype;

import java.util.Objects;

public class Mail implements Cloneable{
    private String name;
    private String emailAddress;
    private String content;

    public Mail(){
        System.out.println("Mail Class Constructor");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmailAddress() {
        return emailAddress;
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return "Mail{" +
                "name='" + name + '\'' +
                ", emailAddress='" + emailAddress + '\'' +
                ", content='" + content + '\'' +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        System.out.println("clone mail object");
        return super.clone();
    }
}
```

​		Main：

```java
public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        Mail mail = new Mail();
        mail.setContent("初始化模板");

        for (int i = 0; i < 10; i++) {
            Mail mailTemp = (Mail) mail.clone();//克隆时并未调用mail的构造器
            mailTemp.setName("姓名" + i);
            mailTemp.setEmailAddress("姓名" + i + "@qq.com");
            mailTemp.setContent("hello:" + i);
            MailUtil.sendMail(mailTemp);
        }
        MailUtil.saveOriginMailRecord(mail);
    }
}

Mail Class Constructor
clone mail object
向姓名0同学，邮件地址：姓名0@qq.com，邮件内容：hello:0发送邮件
clone mail object
向姓名1同学，邮件地址：姓名1@qq.com，邮件内容：hello:1发送邮件
clone mail object
向姓名2同学，邮件地址：姓名2@qq.com，邮件内容：hello:2发送邮件
clone mail object
向姓名3同学，邮件地址：姓名3@qq.com，邮件内容：hello:3发送邮件
clone mail object
向姓名4同学，邮件地址：姓名4@qq.com，邮件内容：hello:4发送邮件
clone mail object
向姓名5同学，邮件地址：姓名5@qq.com，邮件内容：hello:5发送邮件
clone mail object
向姓名6同学，邮件地址：姓名6@qq.com，邮件内容：hello:6发送邮件
clone mail object
向姓名7同学，邮件地址：姓名7@qq.com，邮件内容：hello:7发送邮件
clone mail object
向姓名8同学，邮件地址：姓名8@qq.com，邮件内容：hello:8发送邮件
clone mail object
向姓名9同学，邮件地址：姓名9@qq.com，邮件内容：hello:9发送邮件
存储originMail记录，originMail：初始化模板
```

### （2）抽象类

​		A:

```java
public abstract class A implements Cloneable{
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

​		B:

```java
public class B extends A{
    public static void main(String[] args) throws CloneNotSupportedException {
        B b = new B();
        System.out.println(b);
        System.out.println(b.clone());
    }
}

com.uranus.design.pattern.creational.prototype.abstractprototype.B@13221655
com.uranus.design.pattern.creational.prototype.abstractprototype.B@2f2c9b19
```

### （3）浅拷贝

​		Pig：

```java
public class Pig implements Cloneable {
    private String name;
    private Date birthday;

    public Pig(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "Pig{" +
                "name='" + name + '\'' +
                ", birthday=" + birthday +
                '}' + super.toString();
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date birthday = new Date(0L);
        Pig pig1 = new Pig("A",birthday);
        Pig pig2 = (Pig) pig1.clone();
        System.out.println(pig1);
        System.out.println(pig2);

        pig1.getBirthday().setTime(100000L);
        System.out.println(pig1);
        System.out.println(pig2);
    }
}

Pig{name='A', birthday=Thu Jan 01 08:00:00 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@1fb3ebeb
Pig{name='A', birthday=Thu Jan 01 08:00:00 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@548c4f57
Pig{name='A', birthday=Thu Jan 01 08:01:40 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@1fb3ebeb
Pig{name='A', birthday=Thu Jan 01 08:01:40 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@548c4f57
```

### （4）深拷贝

​		对Pig类做如下更改即可：

```java
protected Object clone() throws CloneNotSupportedException {
    Pig pig = (Pig) super.clone();

    //深拷贝（类里的引用对象也要单独克隆）
    pig.birthday =  (Date) pig.birthday.clone();
    return pig;
}

Pig{name='A', birthday=Thu Jan 01 08:00:00 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@1fb3ebeb
Pig{name='A', birthday=Thu Jan 01 08:00:00 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@548c4f57
Pig{name='A', birthday=Thu Jan 01 08:01:40 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@1fb3ebeb
Pig{name='A', birthday=Thu Jan 01 08:00:00 GMT+08:00 1970}com.uranus.design.pattern.creational.prototype.clone.Pig@548c4f57
```

### （5）克隆破坏单例

​		HungrySingleton：

```java
public class HungrySingleton implements Serializable,Cloneable {
    private final static HungrySingleton hungrySingleton;

    static {
        hungrySingleton = new HungrySingleton();
    }

    private HungrySingleton() {
        if(hungrySingleton!=null){
            throw new RuntimeException("单例构造器禁止反射调用");
        }
    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }

    private Object readResolve() {
        return hungrySingleton;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) throws CloneNotSupportedException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        HungrySingleton hungrySingleton = HungrySingleton.getInstance();
        Method method = hungrySingleton.getClass().getDeclaredMethod("clone");
        method.setAccessible(true);
        HungrySingleton cloneHungrySingleton = (HungrySingleton) method.invoke(hungrySingleton);
        System.out.println(hungrySingleton);
        System.out.println(cloneHungrySingleton);
    }
}

com.uranus.design.pattern.creational.singleton.HungrySingleton@2f2c9b19
com.uranus.design.pattern.creational.singleton.HungrySingleton@31befd9f
```

​		解决方法：

1. HungrySingleton不实现Cloneable

2. HungrySingleton重写的clone改为如下代码：

   ```java
   @Override
   protected Object clone() throws CloneNotSupportedException {
       return getInstance();
   }
   
   com.uranus.design.pattern.creational.singleton.HungrySingleton@2f2c9b19
   com.uranus.design.pattern.creational.singleton.HungrySingleton@2f2c9b19
   ```

> 源码：java.util.arraylist
>
> ​			org.apache.ibatis.cache.CacheKey
>
> ```java
> private int multiplier;
> private int hashcode;
> private long checksum;
> private int count;
> private List<Object> updateList;
> 
> public CacheKey() {
>     this.hashcode = 17;
>     this.multiplier = 37;
>     this.count = 0;
>     this.updateList = new ArrayList();
> }
> 
> public CacheKey clone() throws CloneNotSupportedException {
>     CacheKey clonedCacheKey = (CacheKey)super.clone();
>     clonedCacheKey.updateList = new ArrayList(this.updateList);
>     return clonedCacheKey;
> }
> ```

# 四、结构型模式

## 1.适配器模式

- 定义：将一个类的接口转换成客户期望的另一个接口
- 使原本接口不兼容的类可以一起工作
- 适用场景：
  - 已经存在的类，方法和需求不匹配时（方法结果相同或类似）
  - 不是软件设计阶段考虑的设计模式，是随着软件维护，由于**不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案**。
- 优点：
  - 能提高类的透明性和复用，现有的类复用但不需要改变
  - 目标类和适配器类解耦，提高程序扩展性
  - **符合开闭原则**
- 缺点：
  - 适配器编写过程需要全面考虑，可能会增加系统的复杂性
  - 增加系统代码可读的难度
- 扩展：
  - 类适配器——通过继承
  - 对象适配器——通过组合
- 相关设计模式：
  - 外观模式

### （1）类适配器

​		Adaptee：

```java
public class Adaptee {
    public void adapteeRequest(){
        System.out.println("被适配者的方法");
    }
}
```

​		Target：

```java
public interface Target {
    void request();
}
```

​		Adapter：

```java
public class Adapter extends Adaptee implements Target {
    @Override
    public void request() {
        super.adapteeRequest();
    }
}
```

​		ConcreteTarget：

```java
public class ConcreteTarget implements Target{
    @Override
    public void request() {
        System.out.println("concreteTarget目标方法");
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();

        Target adapterTarget = new Adapter();
        adapterTarget.request();
    }
}

concreteTarget目标方法
被适配者的方法
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210731235718405.png" alt="image-20210731235718405" style="zoom:80%;" />

### （2）对象适配器

​		Adaptee：

```java
public class Adaptee {
    public void adapteeRequest(){
        System.out.println("被适配者的方法");
    }
}
```

​		Target：

```java
public interface Target {
    void request();
}
```

​		ConcreteTarget：

```java
public class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println("concreteTarget目标方法");
    }
}
```

​		Adapter：

```java
public class Adapter implements Target{
    private Adaptee adaptee = new Adaptee();

    @Override
    public void request() {
        adaptee.adapteeRequest();
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();

        Target adapterTarget = new Adapter();
        adapterTarget.request();
    }
}

concreteTarget目标方法
被适配者的方法
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210801000746668.png" alt="image-20210801000746668" style="zoom: 45%;" />

### （3）生活场景：AC220V→DC5V

​		AC220：

```java
public class AC220 {
    public int outputAC220V() {
        int output = 220;
        System.out.println("输出交流电" + output + "V");
        return output;
    }
}
```

​		DC5：

```java
public interface DC5 {
    int outputDC5V();
}
```

​		PowerAdapter：

```java
public class PowerAdapter implements DC5 {
    private AC220 ac220 = new AC220();

    @Override
    public int outputDC5V() {
        int adapterInput = ac220.outputAC220V();

        //变压器
        int adapterOutput = adapterInput / 44;
        System.out.println("使用PowerAdapter输入AC：" + adapterInput + "V\n" + "输出DC：" + adapterOutput + "V");
        return adapterOutput;
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        DC5 dc5 = new PowerAdapter();
        dc5.outputDC5V();
    }
}

输出交流电220V
使用PowerAdapter输入AC：220V
输出DC：5V
```

## 2.装饰者模式

- 定义：在不改变原有对象的基础之上，将功能附加到对象上

  提供了比继承更有弹性的替代方案（扩展原有对象功能）

- 适用场景：

  - 扩展一个类的功能或给一个类添加附加职责
  - **动态的给一个对象添加功能**，这些功能可以再动态地撤销

- 优点：

  - 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能
  - 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果
  - **符合开闭原则**

- 缺点：

  - 会出现更多的代码，更多的类，增加程序复杂性
  - 动态装饰时，多层装饰会更复杂

- 相关设计模式：

  - 代理模式
  - 适配器模式

### （1）v1

​		Battercake：

```java
public class Battercake {
    protected String getDesc(){
        return "煎饼";
    }
    protected int cost(){
        return 8;
    }
}
```

​		BattercakeWithEgg：

```java
public class BattercakeWithEgg extends Battercake {
    @Override
    public String getDesc() {
        return super.getDesc() + "，加一个鸡蛋";
    }

    @Override
    public int cost() {
        return super.cost() + 1;
    }
}

```

​		BattercakeWithEggSausage：

```java
public class BattercakeWithEggSausage extends BattercakeWithEgg {
    @Override
    public String getDesc() {
        return super.getDesc() + "，加一根香肠";
    }

    @Override
    public int cost() {
        return super.cost() + 2;
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Battercake battercake = new Battercake();
        System.out.println(battercake.getDesc() + "销售价格" + battercake.cost() + "元");
        Battercake battercakeWithEgg = new BattercakeWithEgg();
        System.out.println(battercakeWithEgg.getDesc() + "销售价格" + battercakeWithEgg.cost() + "元");
        Battercake battercakeWithEggSausage = new BattercakeWithEggSausage();
        System.out.println(battercakeWithEggSausage.getDesc() + "销售价格" + battercakeWithEggSausage.cost() + "元");
    }
}

煎饼销售价格8元
煎饼，加一个鸡蛋销售价格9元
煎饼，加一个鸡蛋，加一根香肠销售价格11元
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210731202016253.png" alt="image-20210731202016253" style="zoom: 80%;" />

### （2）v2

​		ABattercake：

```java
public abstract class ABattercake {
    protected abstract String getDesc();
    protected abstract int cost();
}
```

​		Battercake：

```java
public class Battercake extends ABattercake{
    @Override
    protected String getDesc() {
        return "煎饼";
    }

    @Override
    protected int cost() {
        return 8;
    }
}
```

​		AbstractDecorator：

```java
public abstract class AbstractDecorator extends ABattercake{
    private ABattercake aBattercake;

    public AbstractDecorator(ABattercake aBattercake) {
        this.aBattercake = aBattercake;
    }

    protected abstract void doSomething();

    @Override
    protected String getDesc() {
        return this.aBattercake.getDesc();
    }

    @Override
    protected int cost() {
        return this.aBattercake.cost();
    }
}
```

​		EggDecorator：

```java
public class EggDecorator extends AbstractDecorator {
    public EggDecorator(ABattercake aBattercake) {
        super(aBattercake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    protected String getDesc() {
        return super.getDesc() + "，加一个鸡蛋";
    }

    @Override
    protected int cost() {
        return super.cost() + 1;
    }
}
```

​		SausageDecorator：

```java
public class SausageDecorator extends AbstractDecorator {
    public SausageDecorator(ABattercake aBattercake) {
        super(aBattercake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    protected String getDesc() {
        return super.getDesc() + "，加一根香肠";
    }

    @Override
    protected int cost() {
        return super.cost() + 2;
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        ABattercake aBattercake;
        aBattercake = new Battercake();
        aBattercake = new EggDecorator(aBattercake);
        aBattercake = new EggDecorator(aBattercake);
        aBattercake = new SausageDecorator(aBattercake);
        System.out.println(aBattercake.getDesc() + "销售价格" + aBattercake.cost() + "元");
    }
}

煎饼，加一个鸡蛋，加一个鸡蛋，加一根香肠销售价格12元
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210731203950693.png" alt="image-20210731203950693" style="zoom:67%;" />

## 3.代理模式

- 定义：为其它对象提供一种代理，以控制对这个对象的访问

  代理对象在客户端和目标对象直接起到中介的作用

- 适用场景：

  - 保护目标对象
  - 增强目标对象

- 优点：

  - 能将代理对象与真实被调用的目标对象分离
  - 一定程度上降低了系统的耦合度，扩展性好
  - 保护目标对象
  - 增强目标对象

- 缺点

  - 造成系统设计中类的数目增加
  - 在客户端和目标对象中增加一个代理对象，会造成请求处理速度变慢
  - 增加系统的复杂度

- 扩展：

  - 静态代理：在代码中显示指定的代理
  - 动态代理：**只能对接口生成代理，并不能针对具体的实现类**
  - CGLib：针对具体的实现类代理，**会生成实现类的子类，覆盖父类的方法，使用的是继承**，所以**一定要注意final修饰符的使用情况**

- 相关设计模式：

  - 装饰者模式
  - 适配器模式

### （1）静态代理

​		Order：

```java
public class Order {
    private Object orderInfo;
    private Integer userId;

    public Object getOrderInfo() {
        return orderInfo;
    }

    public void setOrderInfo(Object orderInfo) {
        this.orderInfo = orderInfo;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }
}
```

​		IOrderDao：

```java
public interface IOrderDao {
    int insert(Order order);
}
```

​		OrderDaoImpl：

```java
public class OrderDaoImpl implements IOrderDao{
    @Override
    public int insert(Order order) {
        System.out.println("Dao层添加Order成功");
        return 1;
    }
}
```

​		IOrderService：

```java
public interface IOrderService {
    int saveOrder(Order order);
}
```

​		OrderServiceImpl：

```java
public class OrderServiceImpl implements IOrderService{

    private IOrderDao iOrderDao;

    @Override
    public int saveOrder(Order order) {
        //Spring会自己注入,这里直接new
        iOrderDao = new OrderDaoImpl();
        System.out.println("Service层调用Dao层添加Order");
        return iOrderDao.insert(order);
    }
}
```

​		OrderServiceStaticProxy：

```java
public class OrderServiceStaticProxy {
    private IOrderService iOrderService;

    public int saveOrder(Order order){
        beforeMethod(order);

        iOrderService = new OrderServiceImpl();
        int result = iOrderService.saveOrder(order);

        afterMethod();
        return result;
    }

    private void beforeMethod(Order order){
        int userId = order.getUserId();
        int dbRouter = userId % 2;
        System.out.println("静态代理分配到[db"+dbRouter+"]处理数据");

        //DataSourseContextHolder.setDBType("db"+String.valueOf(dbRouter));
        System.out.println("静态代理 before code");
    }
    private void afterMethod(){
        System.out.println("静态代理 after code");
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Order order = new Order();
        order.setUserId(1);

        OrderServiceStaticProxy orderServiceStaticProxy = new OrderServiceStaticProxy();
        orderServiceStaticProxy.saveOrder(order);
    }
}

静态代理 before code
静态代理分配到[db1]处理数据
Service层调用Dao层添加Order
Dao层添加Order成功
静态代理 after code
```



<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210801193107136.png" alt="image-20210801193107136" style="zoom:67%;" />

### （2）动态代理

​		OrderServiceDynamicProxy：

```java
public class OrderServiceDynamicProxy implements InvocationHandler {
    private Object target;

    public OrderServiceDynamicProxy(Object target) {
        this.target = target;
    }

    public Object bind(){
        Class cls = target.getClass();
        return Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object argObject = args[0];
        beforeMethod(argObject);
        Object object = method.invoke(target,args);
        afterMethod();
        return object;
    }

    private void beforeMethod(Object object){
        int userId = 0;

        if(object instanceof Object){
            Order order = (Order) object;
            userId = order.getUserId();
        }
        int dbRouter = userId % 2;
        System.out.println("动态代理分配到[db"+dbRouter+"]处理数据");

        //DataSourseContextHolder.setDBType("db"+String.valueOf(dbRouter));
        System.out.println("动态代理 before code");
    }
    private void afterMethod(){
        System.out.println("动态代理 after code");
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Order order = new Order();
        order.setUserId(1);

        IOrderService orderServiceDynamicProxy = (IOrderService) new OrderServiceDynamicProxy(new OrderServiceImpl()).bind();
        orderServiceDynamicProxy.saveOrder(order);
    }
}

动态代理分配到[db1]处理数据
动态代理 before code
Service层调用Dao层添加Order
Dao层添加Order成功
动态代理 after code
```

## 4.外观模式

- 定义：又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口

  外观模式定义了一个高层接口，让子系统更容易使用

- 适用场景：

  - 子系统越来越复杂，增加外观模式提供简单调用接口
  - 构建多层系统结构，利用外观对象作为每层的入口，简化层间调用

- 优点：

  - 简化了调用过程，无需深入了解子系统，防止带来风险
  - 减少系统依赖、松散耦合
  - 更好的划分访问层次
  - **符合迪米特法则，即最少知道原则**

- 缺点：

  - 增加子系统，扩展子系统行为容易引入风险
  - **不符合开闭原则**

- 相关设计模式：

  - 中介者模式
  - 单例模式
  - 抽象工厂模式

​		PointGift：

```java
public class PointsGift {
    private String name;

    public PointsGift(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

​		QualifyService：

```java
public class QualifyService {
    public boolean isAvailable(PointsGift pointsGift) {
        System.out.println("校验" + pointsGift.getName() + "积分资格通过，库存通过");
        return true;
    }
}
```

​		PointsPaymentService：

```java
public class PointsPaymentService {
    public boolean pay(PointsGift pointsGift) {
        //扣减积分
        System.out.println("支付" + pointsGift.getName() + "积分成功");
        return true;
    }
}
```

​		ShippingService：

```java
public class ShippingService {
    public String shipGift(PointsGift pointsGift) {
        //物流系统对接逻辑
        System.out.println(pointsGift.getName() + "进入物流系统");
        String shippingOrderNo = "1";
        return shippingOrderNo;
    }
}
```

​		GiftExchangeService：

```java
public class GiftExchangeService {
    private QualifyService qualifyService = new QualifyService();
    private PointsPaymentService pointsPaymentService = new PointsPaymentService();
    private ShippingService shippingService = new ShippingService();


    public void giftExchange(PointsGift pointsGift) {
        if (qualifyService.isAvailable(pointsGift)) {
            //资格校验通过
            if (pointsPaymentService.pay(pointsGift)) {
                //积分支付成功
                String shippingOrderNo = shippingService.shipGift(pointsGift);
                System.out.println("物流系统下单成功，订单号：" + shippingOrderNo);
            }
        }
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        PointsGift pointsGift = new PointsGift("T-shirt");
        GiftExchangeService giftExchangeService = new GiftExchangeService();

        giftExchangeService.giftExchange(pointsGift);
    }
}

校验T-shirt积分资格通过，库存通过
支付T-shirt积分成功
T-shirt进入物流系统
物流系统下单成功，订单号：1
```

​		当我们要添加新的Service时，必须更改GiftExchangeService的实现，所以不满足开闭原则。

<img src="C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210731194928608.png" alt="image-20210731194928608" style="zoom:50%;" />

## 5.桥接模式

- 定义：将抽象部分与它的具体实现部分分离，使他们都可以独立地变化

  **通过组合的方式建立两个类之间的联系，而不是继承**

- 适用场景：

  - 抽象和具体实现之间增加更多的灵活性
  - 一个类存在多个独立变化的维度，且这多个维度都需要独立进行拓展
  - **不希望使用继承，或因为多层继承导致系统类的个数剧增**

- 优点：

  - 分离抽象部分及其具体实现部分
  - 提高了系统的可扩展性
  - 符合开闭原则
  - 符合合成复用原则

- 缺点：

  - 增加了系统的理解与设计难度
  - 需要正确地识别出系统中两个独立变化的维度

- 相关设计模式

  - 组合模式
  - 适配器模式

​		Account：

```java
public interface Account {
    Account openAccount();
    void showAccountType();
}
```

​		DepositAccount：

```java
public class DepositAccount implements Account{
    @Override
    public Account openAccount() {
        System.out.println("打开定期账户");
        return new DepositAccount();
    }

    @Override
    public void showAccountType() {
        System.out.println("定期账户");
    }
}
```

​		SavingAccount：

```java
public class SavingAccount implements Account{
    @Override
    public Account openAccount() {
        System.out.println("打开活期账户");
        return new SavingAccount();
    }

    @Override
    public void showAccountType() {
        System.out.println("活期账户");
    }
}
```

​		Bank：

```java
public abstract class Bank {
    protected Account account;
    public Bank(Account account){
        this.account = account;
    }
    abstract Account openAccount();
    abstract void showAccountType();
}
```

​		ABCBank：

```java
public class ABCBank extends Bank{
    public ABCBank(Account account) {
        super(account);
    }

    @Override
    void showAccountType() {
        account.showAccountType();
    }

    @Override
    Account openAccount() {
        System.out.println("打开中国农业银行账户");
        account.openAccount();
        return account;
    }
}
```

​		ICBCBank：

```java
public class ICBCBank extends Bank{
    public ICBCBank(Account account) {
        super(account);
    }

    @Override
    void showAccountType() {
        account.showAccountType();
    }

    @Override
    Account openAccount() {
        System.out.println("打开中国工商银行账户");
        account.openAccount();
        return account;
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Bank icbcBank = new ICBCBank(new DepositAccount());
        Account icbcAccount = icbcBank.openAccount();
        icbcAccount.showAccountType();

        Bank icbcBank2 = new ICBCBank(new SavingAccount());
        icbcBank2.openAccount();
        icbcBank2.showAccountType();
        /*Account icbcAccount2 = icbcBank2.openAccount();
        icbcAccount2.showAccountType();*/

        Bank abcBank = new ABCBank(new SavingAccount());
        Account abcAccount = abcBank.openAccount();
        abcAccount.showAccountType();
    }
}

打开中国工商银行账户
打开定期账户
定期账户
打开中国工商银行账户
打开活期账户
活期账户
打开中国农业银行账户
打开活期账户
活期账户
```

> Bank是抽象类，Account是实现类

![image-20210801180828621](http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210801180828621.png)

## 6.组合模式

- 定义：将对象组合成树形结构以表示“部分-整体”的层次结构

  组合模式使**客户端对单个对象和组合对象保持一致的方式处理**

- 适用场景：

  - 希望客户端可以忽略组合对象与单个对象的差异时
  - 处理一个树形结构时

- 优点：

  - 清楚地定义分层次的复杂对象，表示对象的全部或部分层次
  - **让客户端忽略了层次的差异，方便对整个层次结构进行控制**
  - 简化客户端代码
  - 符合开闭原则

- 缺点：

  - 限制类型时较为复杂
  - 使设计变得更加抽象

- 相关设计模式

  - 访问者模式

> 子类将父类作为参数传入，这样Course和CourseCatalog都是CatalogComponent的一部分，且CatalogComponent既可以传入Course，也可以传入CourseCatalog。

​		CatalogComponent：

```java
public abstract class CatalogComponent {
    public void add(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持添加操作");
    }
    public void remove(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持删除操作");
    }
    public String getName(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持获取名称操作");
    }
    public double getPrice(){
        throw new UnsupportedOperationException("不支持获取价格操作");
    }
    public void print(){
        throw new UnsupportedOperationException("不支持打印操作");
    }
}
```

​		Course：

```java
public class Course extends CatalogComponent {
    private String name;
    private double price;

    public Course(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String getName(CatalogComponent catalogComponent) {
        return this.name;
    }

    @Override
    public void print() {
        System.out.println("Course name:" + this.name + " and Price:" + this.price);
    }

    public double getPrice() {
        return this.price;
    }
}
```

​		CourseCatalog：

```java
public class CourseCatalog extends CatalogComponent {
    private List<CatalogComponent> items = new ArrayList<>();
    private String name;
    private Integer level;
    private double price;

    public CourseCatalog(String name, Integer level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void add(CatalogComponent catalogComponent) {
        items.add(catalogComponent);
    }

    @Override
    public String getName(CatalogComponent catalogComponent) {
        return this.name;
    }

    @Override
    public void remove(CatalogComponent catalogComponent) {
        items.remove(catalogComponent);
    }


    public double getPrice() {
        for (int i = 0; i < items.size(); i++) {
            this.price += items.get(i).getPrice();
        }
        return this.price;
    }

    @Override
    public void print() {
        price = 0;
        System.out.println(this.name + ":" + this.getPrice());
        for (CatalogComponent catalogComponent : items) {
            if (this.level != null) {
                for (int i = 0; i < this.level; i++) {
                    System.out.print("  ");
                }
            }
            catalogComponent.print();
        }
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        CatalogComponent linuxCourse = new Course("Linux",11);
        CatalogComponent windowsCourse = new Course("Windows",22);

        CatalogComponent javaCourseCatalog = new CourseCatalog("Java课程目录",2);
        CatalogComponent computerCoursrCatalog = new CourseCatalog("计算机课程目录",1);

        CatalogComponent storeCourse1 = new Course("Javastore1",33);
        CatalogComponent storeCourse2 = new Course("Javastore2",44);
        CatalogComponent designPattern = new Course("Java设计模式",55);

        javaCourseCatalog.add(storeCourse1);
        javaCourseCatalog.add(storeCourse2);
        javaCourseCatalog.add(designPattern);

        computerCoursrCatalog.add(linuxCourse);
        computerCoursrCatalog.add(windowsCourse);
        computerCoursrCatalog.add(javaCourseCatalog);

        computerCoursrCatalog.print();
    }
}
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210801164204834.png" alt="image-20210801164204834" style="zoom: 33%;" />

## 7.享元模式

- 定义：提供了减少对象数量从而改善应用所需的对象结构的方式

  运用共享技术有效地支持大量细粒度的对象

- 适用场景：

  - 常常应用于系统底层的开发，以便解决系统的性能问题
  - 系统中有大量相似对象、需要缓存池的场景

- 优点：

  - 减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率
  - 减少内存之外的其他资源占用，比如时间、句柄

- 缺点：

  - 关注内/外部状态，关注线程安全问题
  - 使系统、程序的逻辑复杂化

- 扩展：

  - 内部状态：在享元对象的内部，且不会随着外部环境的改变而改变
  - 外部状态：在享元对象的外部，会随着外部环境的改变而改变，是不可以共享的状态

- 相关设计模式：

  - 代理模式
  - 单例模式

​		Employee：

```java
public interface Employee {
    void report();
}
```

​		Manager：

```java
public class Manager implements Employee{
    private String department;//外部状态
    private String reportContent;
    private String title = "部门经理";//内部状态

    public Manager(String department) {
        this.department = department;
    }

    public void setReportContent(String reportContent) {
        this.reportContent = reportContent;
    }

    @Override
    public void report() {
        System.out.println(reportContent);
    }
}
```

​		EmployeeFactory：

```java
public class EmployeeFactory {
    private static final Map<String, Employee> EMPLOYEE_MAP = new HashMap<>();

    public static Employee getManager(String department) {
        Manager manager = (Manager) EMPLOYEE_MAP.get(department);
        if (manager == null) {
            manager = new Manager(department);
            String reportContent = department + "部门报告：此次报告的主要内容为...";
            manager.setReportContent(reportContent);
            System.out.println("创建部门经理：" + department);
            System.out.println("创建报告：" + reportContent);
            EMPLOYEE_MAP.put(department, manager);

        }
        return manager;
    }
}
```

​		Test：

```java
public class Test {
    private static final String departments[] = {"RD","QA","PM","BD"};

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            String department = departments[(int) (Math.random()*departments.length)];
            Manager manager = (Manager) EmployeeFactory.getManager(department);
            manager.report();
        }
    }
}

创建部门经理：PM
创建报告：PM部门报告：此次报告的主要内容为...
PM部门报告：此次报告的主要内容为...
创建部门经理：BD
创建报告：BD部门报告：此次报告的主要内容为...
BD部门报告：此次报告的主要内容为...
BD部门报告：此次报告的主要内容为...
PM部门报告：此次报告的主要内容为...
创建部门经理：QA
创建报告：QA部门报告：此次报告的主要内容为...
QA部门报告：此次报告的主要内容为...
创建部门经理：RD
创建报告：RD部门报告：此次报告的主要内容为...
RD部门报告：此次报告的主要内容为...
BD部门报告：此次报告的主要内容为...
PM部门报告：此次报告的主要内容为...
BD部门报告：此次报告的主要内容为...
PM部门报告：此次报告的主要内容为...
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210801013308050.png" alt="image-20210801013308050" style="zoom: 67%;" />

# 五、行为型模式

## 1.策略模式

- 定义：定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户
- 适用场景：
  - 系统有很多类，而它们的区别仅仅在于它们的行为不同
  - 一个系统需要动态地在几种算法中选择一种
- 优点：
  - 符合开闭原则
  - 避免使用多重条件转移语句
  - 提供算法的保密性和安全性
- 缺点：
  - 客户端必须知道所有的策略类，并自行决定使用哪一个策略类
  - 产生很多策略类
- 相关设计模式：
  - 工厂模式
  - 状态模式

​		PromotionStrategy：

```java
public interface PromotionStrategy {
    void doPromotion();
}
```

​		ManJianPromotionStrategy：

```java
public class ManJianPromotionStrategy implements PromotionStrategy{
    @Override
    public void doPromotion() {
        System.out.println("满减促销");
    }
}
```

​		LiJianPromotionStrategy：

```java
public class LiJianPromotionStrategy implements PromotionStrategy{
    @Override
    public void doPromotion() {
        System.out.println("立减促销");
    }
}
```

​		FanXianPromotionStrategy：

```java
public class FanXianPromotionStrategy implements PromotionStrategy{
    @Override
    public void doPromotion() {
        System.out.println("返现促销");
    }
}
```

​		EmptyPromotionStrategy：

```java
public class EmptyPromotionStrategy implements PromotionStrategy{
    @Override
    public void doPromotion() {
        System.out.println("无促销");
    }
}
```

​		PromotionActivity：

```java
public class PromotionActivity {
    private PromotionStrategy promotionStrategy;

    public PromotionActivity(PromotionStrategy promotionStrategy) {
        this.promotionStrategy = promotionStrategy;
    }

    public void executePromotionStrategy(){
        promotionStrategy.doPromotion();
    }
}
```

​		PromotionStrategyFactory：

```java
public class PromotionStrategyFactory {
    private static Map<String,PromotionStrategy> PROMOTION_STRATEGY_MAP = new HashMap<>();
    private static final PromotionStrategy NON_PROMOTION = new EmptyPromotionStrategy();

    static {
        PROMOTION_STRATEGY_MAP.put(PromotionKey.LIJIAN,new LiJianPromotionStrategy());
        PROMOTION_STRATEGY_MAP.put(PromotionKey.MANJIAN,new ManJianPromotionStrategy());
        PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN,new FanXianPromotionStrategy());
    }

    private PromotionStrategyFactory(){

    }
    public static PromotionStrategy getPromotionStrategy(String promotionKey){
        PromotionStrategy promotionStrategy = PROMOTION_STRATEGY_MAP.get(promotionKey);
        return promotionStrategy == null ? NON_PROMOTION : promotionStrategy;
    }

    private interface PromotionKey{
        String LIJIAN="LIJIAN";
        String FANXIAN="FANXIAN";
        String MANJIAN="MANJIAN";
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        String promotionKey = "LIJIAN";
        PromotionActivity promotionActivity = new PromotionActivity(PromotionStrategyFactory.getPromotionStrategy(promotionKey));
        promotionActivity.executePromotionStrategy();
    }
}

立减促销
```

<img src="C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210802173646860.png" alt="image-20210802173646860" style="zoom: 80%;" />

## 2.观察者模式

- 定义：定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新
- 适用场景：
  - 关联行为场景，建立一套触发机制
- 优点：
  - 观察者和被观察者之间建立一个抽象的耦合
  - 观察者模式支持广播通信
- 缺点：
  - 观察者之间有过多的细节依赖，提高时间消耗以及程序复杂度
  - 使用要得当，要避免循环调用

​		Course：

```java
public class Course extends Observable {
    private String courseName;

    public Course(String courseName) {
        this.courseName = courseName;
    }

    public String getCourseName() {
        return courseName;
    }
    public void produceQuestion(Course course,Question question){
        System.out.println(question.getUserName()+"在"+course.getCourseName()+"提交了一个问题");
        setChanged();;
        notifyObservers(question);
    }
}
```

​		Question：

```java
public class Question {
    private String userName;
    private String questionContent;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getQuestionContent() {
        return questionContent;
    }

    public void setQuestionContent(String questionContent) {
        this.questionContent = questionContent;
    }
}
```

​		Teacher：

```java
public class Teacher implements Observer {
    private String teacherName;

    public Teacher(String teacherName) {
        this.teacherName = teacherName;
    }

    @Override
    public void update(Observable o, Object arg) {
        Course course = (Course) o;
        Question question = (Question) arg;
        System.out.println(teacherName+"老师的"+course.getCourseName()+"课程接收到一个"+question.getUserName()+"提交的问答："+question.getQuestionContent());
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Course course = new Course("设计模式");
        Teacher teacher1 = new Teacher("Alpha");
        Teacher teacher2 = new Teacher("Beta");

        course.addObserver(teacher1);
        course.addObserver(teacher2);

        Question question = new Question();
        question.setUserName("Uranus");
        question.setQuestionContent("设计模式有多少种");

        course.produceQuestion(course,question);
    }
}

Uranus在设计模式提交了一个问题
Beta老师的设计模式课程接收到一个Uranus提交的问答：设计模式有多少种
Alpha老师的设计模式课程接收到一个Uranus提交的问答：设计模式有多少种
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210802185548820.png" alt="image-20210802185548820" style="zoom:80%;" />

## 3.责任链模式

- 定义：为请求创建一个接收此次请求对象的链
- 适用场景：
  - 一个请求的处理需要多个对象当中的一个或几个协作处理
- 优点：
  - 请求的发送者和接收者解耦
  - 责任链可以动态组合
- 缺点：
  - 责任链太长或处理时间过长，影响性能
  - 责任链有可能过多
- 相关设计模式
  - 状态模式

​		Course：

```java
public class Course {
    private String name;
    private String article;
    private String video;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getArticle() {
        return article;
    }

    public void setArticle(String article) {
        this.article = article;
    }

    public String getVideo() {
        return video;
    }

    public void setVideo(String video) {
        this.video = video;
    }

    @Override
    public String toString() {
        return "Course{" +
                "name='" + name + '\'' +
                ", article='" + article + '\'' +
                ", video='" + video + '\'' +
                '}';
    }
}
```

​		Approver：

```java
public abstract class Approver {
    //责任链模式核心
    protected Approver approver;

    public void setNextApprover(Approver approver){
        this.approver = approver;
    }

    public abstract void deploy(Course course);

}
```

​		ArticleApprover：

```java
public class ArticleApprover extends Approver{
    @Override
    public void deploy(Course course) {
        if(StringUtils.isNotBlank(course.getArticle())){
            System.out.println(course.getName()+"含有手记，批准");
            if (approver!=null){
                approver.deploy(course);
            }
        }else {
            System.out.println(course.getName()+"不含有手记，不批准");
            return;
        }
    }
}
```

​		VideoApprover：

```java
public class VideoApprover extends Approver{
    @Override
    public void deploy(Course course) {
        if(StringUtils.isNotBlank(course.getVideo())){
            System.out.println(course.getName()+"含有视频，批准");
            if (approver!=null){
                approver.deploy(course);
            }
        }else {
            System.out.println(course.getName()+"不含有视频，不批准");
            return;
        }
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Approver articleApprover = new ArticleApprover();
        Approver videoApprover = new VideoApprover();

        Course course = new Course();
        course.setName("Java");
        course.setArticle("Uranus");
        //course.setVideo("设计模式视频");

        articleApprover.setNextApprover(videoApprover);
        articleApprover.deploy(course);
    }
}

Java含有手记，批准
Java不含有视频，不批准
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210803120905014.png" alt="image-20210803120905014" style="zoom: 80%;" />

## 4.备忘录模式

- 定义：保存一个对象的某个状态，以便在适当的时候恢复对象
- 适用场景：
  - 保存及恢复数据相关业务场景
  - 想恢复到之前的状态
- 优点：
  - 为用户提供一种可恢复机制
  - 存档信息的封装
- 缺点：
  - 资源占用
- 相关设计模式：
  - 状态模式

​		Article：

```java
public class Article {
    private String title;
    private String content;
    private String imgs;

    public Article(String title, String content, String imgs) {
        this.title = title;
        this.content = content;
        this.imgs = imgs;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getImgs() {
        return imgs;
    }

    public void setImgs(String imgs) {
        this.imgs = imgs;
    }

    public ArticleMemento saveToMemento() {
        ArticleMemento articleMemento = new ArticleMemento(this.title, this.content, this.imgs);
        return articleMemento;
    }

    public void undoFromMemento(ArticleMemento articleMemento) {
        this.title = articleMemento.getTitle();
        this.content = articleMemento.getContent();
        this.imgs = articleMemento.getImgs();
    }

    @Override
    public String toString() {
        return "Article{" +
                "title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", imgs='" + imgs + '\'' +
                '}';
    }
}
```

​		ArticleMemento：

```java
public class ArticleMemento {
    private String title;
    private String content;
    private String imgs;

    public ArticleMemento(String title, String content, String imgs) {
        this.title = title;
        this.content = content;
        this.imgs = imgs;
    }

    public String getTitle() {
        return title;
    }

    public String getContent() {
        return content;
    }

    public String getImgs() {
        return imgs;
    }

    @Override
    public String toString() {
        return "ArticleMemento{" +
                "title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", imgs='" + imgs + '\'' +
                '}';
    }
}
```

​		ArticleMementoManager：

```java
public class ArticleMementoManager {
    private final Stack<ArticleMemento> ARTICLE_MEMENTO_STACK = new Stack<>();

    public ArticleMemento getMemento() {
        ArticleMemento articleMemento = ARTICLE_MEMENTO_STACK.pop();
        return articleMemento;
    }

    public void addMemento(ArticleMemento articleMemento) {
        ARTICLE_MEMENTO_STACK.push(articleMemento);
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        ArticleMementoManager articleMementoManager = new ArticleMementoManager();
        Article article = new Article("如影随行的设计模式A", "手记内容A", "手记图片A");
        ArticleMemento articleMemento = article.saveToMemento();
        articleMementoManager.addMemento(articleMemento);
        System.out.println("标题：" + article.getTitle() + "内容：" + article.getContent() + "图片：" + article.getImgs());
        System.out.println("手记完整信息：" + article);

        System.out.println("修改手记start");
        article.setTitle("如影随行的设计模式B");
        article.setContent("手记内容B");
        article.setImgs("手记图片B");
        System.out.println("修改手记end");
        System.out.println("手记完整信息：" + article);

        articleMemento = article.saveToMemento();
        articleMementoManager.addMemento(articleMemento);

        article.setTitle("如影随行的设计模式C");
        article.setContent("手记内容C");
        article.setImgs("手记图片C");

        System.out.println("暂存回退start");
        System.out.println("回退出栈1次");
        articleMemento = articleMementoManager.getMemento();
        article.undoFromMemento(articleMemento);
        System.out.println("手记完整信息：" + article);

        System.out.println("回退出栈2次");
        articleMemento = articleMementoManager.getMemento();
        article.undoFromMemento(articleMemento);

        System.out.println("暂存回退end");
        System.out.println("手记完整信息：" + article);
    }
}
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210803003019173.png" alt="image-20210803003019173"  />

## 5.模板方法模式

- 定义：定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现

  模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤

- 适用场景：

  - 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
  - 各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复

- 优点：

  - 提高复用性
  - 提高扩展性
  - **符合开闭原则**

- 缺点：

  - 类数目增加
  - 增加了系统实现的复杂度
  - 继承关系自身缺点：如果父类添加新的抽象方法，所有子类都要改一遍

- 扩展：

  - 钩子方法

- 相关设计模式：

  - 工厂方法模式是模板方法模式的特殊实现
  - 策略模式

​		ACourse：

```java
public abstract class ACourse {
    protected final void makeCourse(){
        this.makePPT();
        this.makeVideo();
        if (this.needWriteArticle()){
            this.writeArticle();
        }
        this.packageCourse();
    }
    final void makePPT(){
        System.out.println("制作PPT");
    }
    final void makeVideo(){
        System.out.println("制作视频");
    }
    final void writeArticle(){
        System.out.println("编写手记");
    }
    //钩子方法,只要重写该方法就可以影响makeCourse，相当于挂在了makeCourse上
    protected boolean needWriteArticle(){
        return false;
    }
    abstract void packageCourse();
}
```

​		DesignPatternCourse：

```java
public class DesignPatternCourse extends ACourse{
    @Override
    protected boolean needWriteArticle() {
        return true;
    }

    @Override
    void packageCourse() {
        System.out.println("提供课程Java源代码");
    }
}
```

​		FECourse：

```java
public class FECourse extends ACourse{
    private boolean needWriteArticleFlag = false;

    public FECourse(boolean needWriteArticleFlag) {
        this.needWriteArticleFlag = needWriteArticleFlag;
    }

    @Override
    protected boolean needWriteArticle() {
        return this.needWriteArticleFlag;
    }

    @Override
    void packageCourse() {
        System.out.println("提供课程的前端代码");
        System.out.println("提供课程的图片等多媒体素材");
    }
}

```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("后端设计模式课程start——————");
        ACourse designPatternCourse = new DesignPatternCourse();
        designPatternCourse.makeCourse();
        System.out.println("后端设计模式课程end————————");

        System.out.println("前端课程start——————");
        ACourse feCourse = new FECourse(true);
        feCourse.makeCourse();
        System.out.println("前端课程end————————");
    }
}

后端设计模式课程start——————
制作PPT
制作视频
编写手记
提供课程Java源代码
后端设计模式课程end————————
前端课程start——————
制作PPT
制作视频
编写手记
提供课程的前端代码
提供课程的图片等多媒体素材
前端课程end————————
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210802121743894.png" alt="image-20210802121743894" style="zoom: 33%;" />

## 6.迭代器模式

- 定义：提供一种方法，顺序访问一个集合对象中的各种元素，而又不暴露该对象的内部表示
- 适用场景：
  - 访问一个集合对象的内容而无需暴露它的内部表示
  - 为遍历不同的集合结构提供一个统一的接口
- 优点：
  - 分离了集合对象的遍历行为
- 缺点：
  - 类的个数成对增加
- 相关设计模式：
  - 访问者模式

​		Course：

```java
public class Course {
    private String name;

    public Course(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

​		CourseAggregate：

```java
public interface CourseAggregate {
    void addCourse(Course course);
    void removeCourse(Course course);
    CourseIterator getCourseIterator();
}
```

​		CourseAggregateImpl：

```java
public class CourseAggregateImpl implements CourseAggregate{

    private List courseList;

    public CourseAggregateImpl() {
        this.courseList = new ArrayList();
    }

    @Override
    public void addCourse(Course course) {
        courseList.add(course);
    }

    @Override
    public void removeCourse(Course course) {
        courseList.remove(course);
    }

    @Override
    public CourseIterator getCourseIterator() {
        return new CourseIteratorImpl(courseList);
    }
}
```

​		CourseIterator：

```java
public interface CourseIterator {
    Course nextCourse();
    boolean isLastCourse();
}
```

​		CourseIteratorImpl：

```java
public class CourseIteratorImpl implements CourseIterator {
    private List courseList;
    private int position;
    private Course course;

    public CourseIteratorImpl(List courseList) {
        this.courseList = courseList;
    }

    @Override
    public Course nextCourse() {
        System.out.println("返回课程，位置是：" + this.position);
        course = (Course) courseList.get(this.position++);
        return course;
    }

    @Override
    public boolean isLastCourse() {
        if (position < courseList.size()) {
            return false;
        }
        return true;
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        Course course1 = new Course("课程1");
        Course course2 = new Course("课程2");
        Course course3 = new Course("课程3");
        Course course4 = new Course("课程4");
        Course course5 = new Course("课程5");
        Course course6 = new Course("课程6");

        CourseAggregate courseAggregate = new CourseAggregateImpl();
        courseAggregate.addCourse(course1);
        courseAggregate.addCourse(course2);
        courseAggregate.addCourse(course3);
        courseAggregate.addCourse(course4);
        courseAggregate.addCourse(course5);
        courseAggregate.addCourse(course6);

        System.out.println("---------课程列表---------");
        printCourses(courseAggregate);
        courseAggregate.removeCourse(course3);
        courseAggregate.removeCourse(course4);

        System.out.println("-----删除之后的课程列表-----");
        printCourses(courseAggregate);
    }
    public static void printCourses(CourseAggregate courseAggregate){
        CourseIterator courseIterator = courseAggregate.getCourseIterator();
        while (!courseIterator.isLastCourse()){
            Course course = courseIterator.nextCourse();
            System.out.println(course.getName());
        }
    }
}

---------课程列表---------
返回课程，位置是：0
课程1
返回课程，位置是：1
课程2
返回课程，位置是：2
课程3
返回课程，位置是：3
课程4
返回课程，位置是：4
课程5
返回课程，位置是：5
课程6
-----删除之后的课程列表-----
返回课程，位置是：0
课程1
返回课程，位置是：1
课程2
返回课程，位置是：2
课程5
返回课程，位置是：3
课程6
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210802125941523.png" alt="image-20210802125941523" style="zoom: 80%;" />

## 7.中介者模式

- 定义：定义了一个封装一组对象如何交互的对象

  通过使对象明确地相互作用来促进松散耦合，并允许独立地改变它们的交互

- 适用场景：

  - 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解
  - 交互的公共行为，如果需要改变行为则可以增加新的中介者类

- 优点：

  - 将一对多转化成了一对一，降低程序复杂度
  - 类之间解耦

- 缺点：

  - 中介者过多，导致系统复杂

- 相关设计模式：

  - 观察者模式

​		StudyGroup：

```java
public class StudyGroup {
    public static void showMessage(User user, String message) {
        System.out.println(new Date().toString() + "[" + user.getName() + "]:" + message);
    }
}
```

​		User：

```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void sendMessage(String message) {
        StudyGroup.showMessage(this, message);
    }
}

```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        User user1 = new User("Uranus");
        User user2 = new User("GYZ");

        user1.sendMessage("Hello");
        user2.sendMessage("OK");
    }
}
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210803013320947.png" alt="image-20210803013320947" style="zoom:67%;" />

## 8.命令模式

- 定义：将“请求”封装成对象，以便使用不同的请求

  命令模式解决了应用程序中对象的职责以及它们之间的通信方式

- 适用场景：

  - 请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互
  - 需要抽象出等待执行的行为

- 优点：

  - 降低耦合
  - 容易扩展新命令或者一组命令

- 缺点：

  - 命令的无限扩展会增加类的数量，提高系统实现复杂度

- 相关设计模式：

  - 备忘录模式

​		Command：

```java
public interface Command {
    void execute();
}
```

​		CourseVideo：

```java
public class CourseVideo {
    private String name;

    public CourseVideo(String name) {
        this.name = name;
    }

    public void open() {
        System.out.println(this.name + "课程视频开放");
    }

    public void close() {
        System.out.println(this.name + "课程视频关闭");
    }
}
```

​		OpenCourseVideoCommand：

```java
public class OpenCourseVideoCommand implements Command{

    private CourseVideo courseVideo;

    public OpenCourseVideoCommand(CourseVideo courseVideo) {
        this.courseVideo = courseVideo;
    }

    @Override
    public void execute() {
        courseVideo.open();
    }
}
```

​		CloseCourseVideoCommand：

```java
public class CloseCourseVideoCommand implements Command{
    private CourseVideo courseVideo;

    public CloseCourseVideoCommand(CourseVideo courseVideo) {
        this.courseVideo = courseVideo;
    }

    @Override
    public void execute() {
        courseVideo.close();
    }
}

```

​		Staff：

```java
public class Staff {
    private List<Command> commandList = new ArrayList<>();
    public void addCommand(Command command){
        commandList.add(command);
    }

    public void executeCommands(){
        for (Command command: commandList){
            command.execute();
        }
        commandList.clear();
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        CourseVideo courseVideo = new CourseVideo("设计模式");
        OpenCourseVideoCommand openCourseVideoCommand = new OpenCourseVideoCommand(courseVideo);
        CloseCourseVideoCommand closeCourseVideoCommand = new CloseCourseVideoCommand(courseVideo);

        Staff staff = new Staff();
        staff.addCommand(openCourseVideoCommand);
        staff.addCommand(closeCourseVideoCommand);

        staff.executeCommands();
    }
}

设计模式课程视频开放
设计模式课程视频关闭
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210803012227517.png" alt="image-20210803012227517" style="zoom: 80%;" />

## 9.访问者模式

- 定义：封装作用于某数据结构（如List/Set/Map等）中的各元素的操作

  可以在不改变各元素的类的前提下，定义作用于这些元素的操作

- 适用场景：

  - 一个数据结构（如List/Set/Map等）包含很多类型对象
  - 数据结构和数据操作分离

- 优点：

  - 增加新的操作很容易，即增加一个新的访问者

- 缺点：

  - 增加新的数据结构困难
  - 具体元素变更比较麻烦

- 相关设计模式：

  - 迭代器模式

> **核心：根据不同的visitor对相同的数据产生不同的操作行为**

​		Course：

```java
public abstract class Course {
    private String name;
    private double jixiao;

    public double getJixiao() {
        return jixiao;
    }

    public void setJixiao(double jixiao) {
        this.jixiao = jixiao;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public abstract void accept(IVisitor iVisitor);
}
```

​		FreeCourse：

```java
public class FreeCourse extends Course{
    @Override
    public void accept(IVisitor iVisitor) {
        iVisitor.visit(this);
    }
}
```

​		CodingCourse：

```java
public class CodingCourse extends Course{
    private int price;

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    @Override
    public void accept(IVisitor iVisitor) {
        iVisitor.visit(this);
    }
}
```

​		IVisitor：

```java
public interface IVisitor {
    void visit(FreeCourse freeCourse);
    void visit(CodingCourse codingCourse);
}
```

​		Visitor：

```java
public class Visitor implements IVisitor {
    @Override
    public void visit(FreeCourse freeCourse) {
        System.out.println("免费课程" + freeCourse.getName());
    }

    @Override
    public void visit(CodingCourse codingCourse) {
        System.out.println("实战课程" + codingCourse.getName() + " 价格：" + codingCourse.getPrice());
    }
}
```

​		LeaderVisitor：

```java
public class LeaderVisitor implements IVisitor {
    @Override
    public void visit(FreeCourse freeCourse) {
        System.out.println("免费课程" + freeCourse.getName() + "的绩效为" + freeCourse.getJixiao());
    }

    @Override
    public void visit(CodingCourse codingCourse) {
        System.out.println("实战课程" + codingCourse.getName() + " 价格：" + codingCourse.getPrice() + " 绩效为" + codingCourse.getJixiao());
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        List<Course> courseList = new ArrayList<>();

        FreeCourse freeCourse = new FreeCourse();
        freeCourse.setName("Java");
        freeCourse.setJixiao(1);

        CodingCourse codingCourse = new CodingCourse();
        codingCourse.setName("设计模式");
        codingCourse.setPrice(100);
        codingCourse.setJixiao(200);

        courseList.add(freeCourse);
        courseList.add(codingCourse);

        for(Course course:courseList){
            course.accept(new Visitor());
        }

        for(Course course:courseList){
            course.accept(new LeaderVisitor());
        }
    }
}

免费课程Java
实战课程设计模式 价格：100
免费课程Java的绩效为1.0
实战课程设计模式 价格：100 绩效为200.0
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210803161019267.png" alt="image-20210803161019267" style="zoom:80%;" />

## 10.解释器模式

- 定义：给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示来解释语言中的句子

  为了解释一种语言，而为语言创建的解释器

- 适用场景：

  - 某个特定类型问题发生频率足够高

- 优点：

  - 语法由很多类表示，容易改变及扩展此“语言”

- 缺点：

  - 当语法规则数目太多时，增加了系统复杂度

- 相关设计模式：

  - 适配器模式

​		OperatorUtil：

```java
public class OperatorUtil {
    public static boolean isOperator(String symbol) {
        return (symbol.equals("+") || symbol.equals("*"));

    }



    public static Interpreter getExpressionObject(Interpreter firstExpression, Interpreter secondExpression, String symbol) {
        if (symbol.equals("+")) {
            return new AddInterpreter(firstExpression, secondExpression);
        } else if (symbol.equals("*")) {
            return new MultiInterpreter(firstExpression, secondExpression);
        }
        return null;
    }
}
```

​		Interpreter：

```java
public interface Interpreter {
    int interpret();
}
```

​		NumberInterpreter：

```java
public class NumberInterpreter implements Interpreter {
    private int number;
    public NumberInterpreter(int number){
        this.number=number;
    }
    public NumberInterpreter(String number){
        this.number=Integer.parseInt(number);
    }
    @Override
    public int interpret(){
        return this.number;
    }
}
```

​		AddInterpreter：

```java
public class AddInterpreter implements Interpreter {
    private Interpreter firstExpression,secondExpression;
    public AddInterpreter(Interpreter firstExpression, Interpreter secondExpression){
        this.firstExpression=firstExpression;
        this.secondExpression=secondExpression;
    }
    @Override
    public int interpret(){
        return this.firstExpression.interpret()+this.secondExpression.interpret();
    }
    @Override
    public String toString(){
        return "+";
    }
}
```

​		MultiInterpreter：

```java
public class MultiInterpreter implements Interpreter {

    private Interpreter firstExpression,secondExpression;
    public MultiInterpreter(Interpreter firstExpression, Interpreter secondExpression){
        this.firstExpression=firstExpression;
        this.secondExpression=secondExpression;
    }
    @Override
    public int interpret(){
        return this.firstExpression.interpret()*this.secondExpression.interpret();
    }
    @Override
    public String toString(){
        return "*";
    }

}
```

​		UranusExpressionParser：

```java
public class UranusExpressionParser {
    private Stack<Interpreter> stack = new Stack<Interpreter>();

    public int parse(String str) {
        String[] strItemArray = str.split(" ");
        for (String symbol : strItemArray) {
            if (!OperatorUtil.isOperator(symbol)) {
                Interpreter numberExpression = new NumberInterpreter(symbol);
                stack.push(numberExpression);
                System.out.println(String.format("入栈: %d", numberExpression.interpret()));
            } else {
                //是运算符号，可以计算
                Interpreter firstExpression = stack.pop();
                Interpreter secondExpression = stack.pop();
                System.out.println(String.format("出栈: %d 和 %d",
                        firstExpression.interpret(), secondExpression.interpret()));
                Interpreter operator = OperatorUtil.getExpressionObject(firstExpression, secondExpression, symbol);
                System.out.println(String.format("应用运算符: %s", operator));
                int result = operator.interpret();
                NumberInterpreter resultExpression = new NumberInterpreter(result);
                stack.push(resultExpression);
                System.out.println(String.format("阶段结果入栈: %d", resultExpression.interpret()));
            }
        }
        int result = stack.pop().interpret();
        return result;

    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        String geelyInputStr="6 100 11 + *";
        UranusExpressionParser expressionParser=new UranusExpressionParser();
        int result=expressionParser.parse(geelyInputStr);
        System.out.println("解释器计算结果: "+result);
    }
}
```



![image-20210802180533321](C:\Users\Ursnus\AppData\Roaming\Typora\typora-user-images\image-20210802180533321.png)

## 11.状态模式

- 定义：允许一个对象在其内部对象改变时，改变它的行为
- 适用场景：
  - 一个对象存在多个状态（不同状态下的行为不同），且状态可相互转换
- 优点：
  - 将不同的状态隔离
  - 把各种状态的转换逻辑，分布到State的子类中，减少相互间依赖
  - 增加新的状态非常简单
- 缺点：
  - 状态多的业务场景导致类数目增加，系统会更复杂
- 相关设计模式：
  - 享元模式

​		CourseVideoState：

```java
public abstract class CourseVideoState {
    protected CourseVideoContext courseVideoContext;

    public void setCourseVideoContext(CourseVideoContext courseVideoContext) {
        this.courseVideoContext = courseVideoContext;
    }

    public abstract void play();
    public abstract void speed();
    public abstract void pause();
    public abstract void stop();
}
```

​		PlayState：

```java
public class PlayState extends CourseVideoState{
    @Override
    public void play() {
        System.out.println("正常播放课程视频状态");
    }

    @Override
    public void speed() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);
    }

    @Override
    public void pause() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}
```

​		SpeedState：

```java
public class SpeedState extends CourseVideoState {
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void speed() {
        System.out.println("快进播放课程视频状态");
    }

    @Override
    public void pause() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PAUSE_STATE);
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}
```

​		PauseState：

```java
public class PauseState extends CourseVideoState{
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void speed() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.SPEED_STATE);
    }

    @Override
    public void pause() {
        System.out.println("暂停播放课程视频状态");
    }

    @Override
    public void stop() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.STOP_STATE);
    }
}
```

​		StopState：

```java
public class StopState extends CourseVideoState{
    @Override
    public void play() {
        super.courseVideoContext.setCourseVideoState(CourseVideoContext.PLAY_STATE);
    }

    @Override
    public void speed() {
        System.out.println("Error,停止状态不能快进");
    }

    @Override
    public void pause() {
        System.out.println("Error,停止状态不能暂停");
    }

    @Override
    public void stop() {
        System.out.println("停止播放课程视频状态");
    }
}
```

​		CourseVideoContext：

```java
public class CourseVideoContext {
    private CourseVideoState courseVideoState;
    public final static PlayState PLAY_STATE = new PlayState();
    public final static SpeedState SPEED_STATE = new SpeedState();
    public final static PauseState PAUSE_STATE = new PauseState();
    public final static StopState STOP_STATE = new StopState();

    public CourseVideoState getCourseVideoState() {
        return courseVideoState;
    }

    public void setCourseVideoState(CourseVideoState courseVideoState) {
        this.courseVideoState = courseVideoState;
        this.courseVideoState.setCourseVideoContext(this);
    }
    public void play(){
        this.courseVideoState.play();
    }
    public void speed(){
        this.courseVideoState.speed();
    }
    public void pause(){
        this.courseVideoState.pause();
    }
    public void stop(){
        this.courseVideoState.stop();
    }
}
```

​		Test：

```java
public class Test {
    public static void main(String[] args) {
        CourseVideoContext courseVideoContext = new CourseVideoContext();
        courseVideoContext.setCourseVideoState(new PlayState());
        System.out.println("当前状态："+courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.pause();
        System.out.println("当前状态："+courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.speed();
        System.out.println("当前状态："+courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.stop();
        System.out.println("当前状态："+courseVideoContext.getCourseVideoState().getClass().getSimpleName());

        courseVideoContext.speed();
    }
}

当前状态：PlayState
当前状态：PauseState
当前状态：SpeedState
当前状态：StopState
Error,停止状态不能快进
当前状态：StopState
```

<img src="http://uranus-picture.oss-cn-beijing.aliyuncs.com/img/image-20210803171053988.png" alt="image-20210803171053988" style="zoom:80%;" />